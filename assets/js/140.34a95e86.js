(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{519:function(e,t,n){"use strict";n.r(t);var o=n(44),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"exceptions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exceptions"}},[e._v("#")]),e._v(" Exceptions")]),e._v(" "),n("blockquote",[n("p",[e._v("The word “exception” is used in the same sense as the phrase “I take exception to that.”")])]),e._v(" "),n("p",[e._v("An exceptional condition prevents the continuation of the current function or scope. At the point the problem occurs, you might not know what to do with it, but you cannot continue within the current context. You don’t have enough information to fix the problem. So you must stop and hand the problem to another context that’s able to take appropriate action.")]),e._v(" "),n("p",[e._v("This atom covers the basics of "),n("em",[e._v("exceptions")]),e._v(" as an error-reporting mechanism. In [Section VI: Preventing Failure](javascript:void(0)), we look at other ways to deal with problems.")]),e._v(" "),n("p",[e._v("It’s important to distinguish an exceptional condition from a normal problem. A normal problem has enough information in the current context to cope with the issue. With an exceptional condition, you cannot continue processing. All you can do is leave, relegating the problem to an external context. This is what happens when you "),n("em",[e._v("throw an exception")]),e._v(". The exception is the object that is “thrown” from the site of the error.")]),e._v(" "),n("p",[e._v("Consider "),n("code",[e._v("toInt()")]),e._v(", which converts a "),n("code",[e._v("String")]),e._v(" to an "),n("code",[e._v("Int")]),e._v(". What happens if you call this function for a "),n("code",[e._v("String")]),e._v(" that doesn’t contain an integer value?")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Exceptions/ToIntException.kt\npackage exceptions\n\nfun erroneousCode() {\n  // Uncomment this line to get an exception:\n  // val i = "1$".toInt()        // [1]\n}\n\nfun main() {\n  erroneousCode()\n}\n')])])]),n("p",[e._v("Uncommenting line "),n("strong",[e._v("[1]")]),e._v(" produces an exception. Here, the failing line is commented so we don’t stop the book’s build, which checks whether each example compiles and runs as expected.")]),e._v(" "),n("p",[e._v("When an exception is thrown, the path of execution—the one that can’t be continued—stops, and the exception object ejects from the current context. Here, it exits the context of "),n("code",[e._v("erroneousCode()")]),e._v(" and goes out to the context of "),n("code",[e._v("main()")]),e._v(". In this case, Kotlin only reports the error; the programmer has presumably made a mistake and must fix the code.")]),e._v(" "),n("p",[e._v("When an exception isn’t caught, the program aborts and displays a "),n("em",[e._v("stack trace")]),e._v(" containing detailed information. Uncommenting line "),n("strong",[e._v("[1]")]),e._v(" in "),n("code",[e._v("ToIntException.kt")]),e._v(", produces the following output:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Exception in thread "main" java.lang.NumberFormatException: For input s\\\ntring: "1$"\n  at java.lang.NumberFormatException.forInputString(NumberFormatExcepti\\\non.java:65)\n  at java.lang.Integer.parseInt(Integer.java:580)\n  at java.lang.Integer.parseInt(Integer.java:615)\n  at ToIntExceptionKt.erroneousCode(at ToIntException.kt:6)\n  at ToIntExceptionKt.main(at ToIntException.kt:10)\n')])])]),n("p",[e._v("The stack trace gives details such as the file and line where the exception occurred, so you can quickly discover the issue. The last two lines show the problem: in line 10 of "),n("code",[e._v("main()")]),e._v(" we call "),n("code",[e._v("erroneousCode()")]),e._v(". Then, more precisely, in line 6 of "),n("code",[e._v("erroneousCode()")]),e._v(" we call "),n("code",[e._v("toInt()")]),e._v(".")]),e._v(" "),n("p",[e._v("To avoid commenting and uncommenting code to display exceptions, we use the "),n("code",[e._v("capture()")]),e._v(" function from the "),n("code",[e._v("AtomicTest")]),e._v(" package:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Exceptions/IntroducingCapture.kt\nimport atomictest.*\n\nfun main() {\n  capture {\n    "1$".toInt()\n  } eq "NumberFormatException: " +\n    """For input string: "1$""""\n}\n')])])]),n("p",[e._v("Using "),n("code",[e._v("capture()")]),e._v(", we compare the generated exception to the expected error message. "),n("code",[e._v("capture()")]),e._v(" isn’t very helpful for normal programming—it’s designed specifically for this book, so you can see the exception and know that the output has been checked by the book’s build system.")]),e._v(" "),n("p",[e._v("Another strategy when you can’t successfully produce the expected result is to return "),n("code",[e._v("null")]),e._v(", which is a special constant denoting “no value.” You can return "),n("code",[e._v("null")]),e._v(" instead of a value of any type. Later in [Nullable Types](javascript:void(0)) we discuss the way "),n("code",[e._v("null")]),e._v(" affects the type of the resulting expression.")]),e._v(" "),n("p",[e._v("The Kotlin standard library contains "),n("code",[e._v("String.toIntOrNull()")]),e._v(" which performs the conversion if the "),n("code",[e._v("String")]),e._v(" contains an integer number, or produces "),n("code",[e._v("null")]),e._v(" if the conversion is impossible—"),n("code",[e._v("null")]),e._v(" is a simple way to indicate failure:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Exceptions/IntroducingNull.kt\nimport atomictest.eq\n\nfun main() {\n  "1$".toIntOrNull() eq null\n}\n')])])]),n("p",[e._v("Suppose we calculate average income over a period of months:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Exceptions/AverageIncome.kt\npackage firstversion\nimport atomictest.*\n\nfun averageIncome(income: Int, months: Int) =\n  income / months\n\nfun main() {\n  averageIncome(3300, 3) eq 1100\n  capture {\n    averageIncome(5000, 0)\n  } eq "ArithmeticException: / by zero"\n}\n')])])]),n("p",[e._v("If "),n("code",[e._v("months")]),e._v(" is zero, the division in "),n("code",[e._v("averageIncome()")]),e._v(" throws an "),n("code",[e._v("ArithmeticException")]),e._v(". Unfortunately, this doesn’t tell us anything about why the error occurred, what the denominator means and whether it can legally be zero in the first place. This is clearly a bug in the code—"),n("code",[e._v("averageIncome()")]),e._v(" should cope with a "),n("code",[e._v("months")]),e._v(" of "),n("code",[e._v("0")]),e._v(" in a way that prevents a divide-by-zero error.")]),e._v(" "),n("p",[e._v("Let’s modify "),n("code",[e._v("averageIncome()")]),e._v(" to produce more information about the source of the problem. If "),n("code",[e._v("months")]),e._v(" is zero, we can’t return a regular integer value as a result. One strategy is to return "),n("code",[e._v("null")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// Exceptions/AverageIncomeWithNull.kt\npackage withnull\nimport atomictest.eq\n\nfun averageIncome(income: Int, months: Int) =\n  if (months == 0)\n    null\n  else\n    income / months\n\nfun main() {\n  averageIncome(3300, 3) eq 1100\n  averageIncome(5000, 0) eq null\n}\n")])])]),n("p",[e._v("If a function can return "),n("code",[e._v("null")]),e._v(", Kotlin requires that you check the result before using it (this is covered in [Nullable Types](javascript:void(0))). Even if you only want to display output to the user, it’s better to say “No full month periods have passed,” rather than “Your average income for the period is: null.”")]),e._v(" "),n("p",[e._v("Instead of executing "),n("code",[e._v("averageIncome()")]),e._v(" with the wrong arguments, you can throw an exception—escape and force some other part of the program to manage the issue. You "),n("em",[e._v("could")]),e._v(" just allow the default "),n("code",[e._v("ArithmeticException")]),e._v(", but it’s often more useful to throw a specific exception with a detailed error message. When, after a couple of years in production, your application suddenly throws an exception because a new feature calls "),n("code",[e._v("averageIncome()")]),e._v(" without properly checking the arguments, you’ll be grateful for that message:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Exceptions/AverageIncomeWithException.kt\npackage properexception\nimport atomictest.*\n\nfun averageIncome(income: Int, months: Int) =\n  if (months == 0)\n    throw IllegalArgumentException(    // [1]\n      "Months can\'t be zero")\n  else\n    income / months\n\nfun main() {\n  averageIncome(3300, 3) eq 1100\n  capture {\n    averageIncome(5000, 0)\n  } eq "IllegalArgumentException: " +\n    "Months can\'t be zero"\n}\n')])])]),n("ul",[n("li",[n("strong",[e._v("[1]")]),e._v(" When throwing an exception, the "),n("code",[e._v("throw")]),e._v(" keyword is followed by the exception to be thrown, along with any arguments it might need. Here we use the standard exception class "),n("code",[e._v("IllegalArgumentException")]),e._v(".")])]),e._v(" "),n("p",[e._v("Your goal is to generate the most useful messages possible to simplify the support of your application in the future. Later you’ll learn to define your own exception types and make them specific to your circumstances.")]),e._v(" "),n("p",[n("em",[n("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);