(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{535:function(e,t,l){"use strict";l.r(t);var n=l(44),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"extensions-for-nullable-types"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#extensions-for-nullable-types"}},[e._v("#")]),e._v(" Extensions for Nullable Types")]),e._v(" "),l("blockquote",[l("p",[e._v("Sometimes it’s not what it looks like.")])]),e._v(" "),l("p",[l("code",[e._v("s?.f()")]),e._v(" implies that "),l("code",[e._v("s")]),e._v(" is nullable—otherwise you could simply call "),l("code",[e._v("s.f()")]),e._v(". Similarly, "),l("code",[e._v("t.f()")]),e._v(" seems to imply that "),l("code",[e._v("t")]),e._v(" is non-nullable because Kotlin doesn’t require a safe call or programmatic check. However, "),l("code",[e._v("t")]),e._v(" is not necessarily non-nullable.")]),e._v(" "),l("p",[e._v("The Kotlin standard library provides "),l("code",[e._v("String")]),e._v(" extension functions, including:")]),e._v(" "),l("ul",[l("li",[l("code",[e._v("isNullOrEmpty()")]),e._v(": Tests whether the receiver "),l("code",[e._v("String")]),e._v(" is "),l("code",[e._v("null")]),e._v(" or empty.")]),e._v(" "),l("li",[l("code",[e._v("isNullOrBlank()")]),e._v(": Performs the same check as "),l("code",[e._v("isNullOrEmpty()")]),e._v(" "),l("em",[e._v("and")]),e._v(" allows the receiver "),l("code",[e._v("String")]),e._v(" to consist solely of whitespace characters, including tabs ("),l("code",[e._v("\\t")]),e._v(") and newlines ("),l("code",[e._v("\\n")]),e._v(").")])]),e._v(" "),l("p",[e._v("Here’s a basic test of these functions:")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('// NullableExtensions/StringIsNullOr.kt\nimport atomictest.eq\n\nfun main() {\n  val s1: String? = null\n  s1.isNullOrEmpty() eq true\n  s1.isNullOrBlank() eq true\n\n  val s2 = ""\n  s2.isNullOrEmpty() eq true\n  s2.isNullOrBlank() eq true\n\n  val s3: String = " \\t\\n"\n  s3.isNullOrEmpty() eq false\n  s3.isNullOrBlank() eq true\n}\n')])])]),l("p",[e._v("The function names suggest they are for nullable types. However, even though "),l("code",[e._v("s1")]),e._v(" is nullable, you can call "),l("code",[e._v("isNullOrEmpty()")]),e._v(" or "),l("code",[e._v("isNullOrBlank()")]),e._v(" without a safe call or explicit check. That’s because these are extension functions on the nullable type "),l("code",[e._v("String?")]),e._v(".")]),e._v(" "),l("p",[e._v("We can rewrite "),l("code",[e._v("isNullOrEmpty()")]),e._v(" as a non-extension function that takes the nullable "),l("code",[e._v("String s")]),e._v(" as a parameter:")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('// NullableExtensions/NullableParameter.kt\npackage nullableextensions\nimport atomictest.eq\n\nfun isNullOrEmpty(s: String?): Boolean =\n  s == null || s.isEmpty()\n\nfun main() {\n  isNullOrEmpty(null) eq true\n  isNullOrEmpty("") eq true\n}\n')])])]),l("p",[e._v("Because "),l("code",[e._v("s")]),e._v(" is nullable, we explicitly check for "),l("code",[e._v("null")]),e._v(" or empty. The expression "),l("code",[e._v("s == null || s.isEmpty()")]),e._v(" uses "),l("em",[e._v("short-circuiting")]),e._v(": if the first part of the expression is "),l("code",[e._v("true")]),e._v(", the rest of the expression is not evaluated, thus preventing a "),l("code",[e._v("null")]),e._v(" pointer exception.")]),e._v(" "),l("p",[e._v("Extension functions use "),l("code",[e._v("this")]),e._v(" to represent the receiver (the object of the type being extended). To make the receiver nullable, add "),l("code",[e._v("?")]),e._v(" to the type being extended:")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('// NullableExtensions/NullableExtension.kt\npackage nullableextensions\nimport atomictest.eq\n\nfun String?.isNullOrEmpty(): Boolean =\n  this == null || isEmpty()\n\nfun main() {\n  "".isNullOrEmpty() eq true\n}\n')])])]),l("p",[l("code",[e._v("isNullOrEmpty()")]),e._v(" is more readable as an extension function.")]),e._v(" "),l("ul",[l("li",[e._v("-")])]),e._v(" "),l("p",[e._v("Take care when using extensions for nullable types. They are great for simple cases like "),l("code",[e._v("isNullOrEmpty()")]),e._v(" and "),l("code",[e._v("isNullOrBlank()")]),e._v(", especially with self-explanatory names that imply the receiver might be "),l("code",[e._v("null")]),e._v(". In general, it’s better to declare regular (non-nullable) extensions. Safe calls and explicit checks clarify the receiver’s nullability, while extensions for nullable types may conceal nullability and confuse the reader of your code (probably, “future you”).")]),e._v(" "),l("p",[l("em",[l("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);