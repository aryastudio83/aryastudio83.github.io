(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{508:function(e,n,t){"use strict";t.r(n);var s=t(44),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"expressions-statements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expressions-statements"}},[e._v("#")]),e._v(" Expressions & Statements")]),e._v(" "),t("blockquote",[t("p",[t("em",[e._v("Statements")]),e._v(" and "),t("em",[e._v("expressions")]),e._v(" are the smallest useful fragments of code in most programming languages.")])]),e._v(" "),t("p",[e._v("There’s a basic difference: a statement has an effect, but produces no result. An expression always produces a result.")]),e._v(" "),t("p",[e._v("Because it doesn’t produce a result, a statement must change the state of its surroundings to be useful. Another way to say this is “a statement is called for its "),t("em",[e._v("side effects")]),e._v("” (that is, what it does "),t("em",[e._v("other")]),e._v(" than producing a result). As a memory aid:")]),e._v(" "),t("blockquote",[t("p",[t("em",[e._v("A statement changes state")]),e._v(".")])]),e._v(" "),t("p",[e._v("One definition of “express” is “to force or squeeze out,” as in “to express the juice from an orange.” So")]),e._v(" "),t("blockquote",[t("p",[t("em",[e._v("An expression expresses")]),e._v(".")])]),e._v(" "),t("p",[e._v("That is, it produces a result.")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("for")]),e._v(" loop is a statement in Kotlin. You cannot assign it because there’s no result:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ExpressionsStatements/ForIsAStatement.kt\n\nfun main() {\n  // Can't do this:\n  // val f = for(i in 1..10) {}\n  // Compiler error message:\n  // for is not an expression, and\n  // only expressions are allowed here\n}\n")])])]),t("p",[e._v("A "),t("code",[e._v("for")]),e._v(" loop is used for its side effects.")]),e._v(" "),t("p",[e._v("An expression produces a value, which can be assigned or used as part of another expression, whereas a statement is always a top-level element.")]),e._v(" "),t("p",[e._v("Every function call is an expression. Even if the function returns "),t("code",[e._v("Unit")]),e._v(" and is called only for its side effects, the result can still be assigned:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ExpressionsStatements/UnitReturnType.kt\n\nfun unitFun() = Unit\n\nfun main() {\n  println(unitFun())\n  val u1: Unit = println(42)\n  println(u1)\n  val u2 = println(0) // Type inference\n  println(u2)\n}\n/* Output:\nkotlin.Unit\n42\nkotlin.Unit\n0\nkotlin.Unit\n*/\n")])])]),t("p",[e._v("The "),t("code",[e._v("Unit")]),e._v(" type contains a single value called "),t("code",[e._v("Unit")]),e._v(", which you can return directly, as seen in "),t("code",[e._v("unitFun()")]),e._v(". Calling "),t("code",[e._v("println()")]),e._v(" also returns "),t("code",[e._v("Unit")]),e._v(". The "),t("code",[e._v("val u1")]),e._v(" captures the return value of "),t("code",[e._v("println()")]),e._v(" and is explicitly declared as "),t("code",[e._v("Unit")]),e._v(" while "),t("code",[e._v("u2")]),e._v(" uses type inference.")]),e._v(" "),t("p",[t("code",[e._v("if")]),e._v(" creates an expression, so you can assign its result:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ExpressionsStatements/AssigningAnIf.kt\n\nfun main() {\n  val result1 = if (11 > 42) 9 else 5\n\n  val result2 = if (1 < 2) {\n    val a = 11\n    a + 42\n  } else 42\n\n  val result3 =\n    if ('x' < 'y')\n      println(\"x < y\")\n    else\n      println(\"x > y\")\n\n  println(result1)\n  println(result2)\n  println(result3)\n}\n/* Output:\nx < y\n5\n53\nkotlin.Unit\n*/\n")])])]),t("p",[e._v("The first output line is "),t("code",[e._v("x < y")]),e._v(", even though "),t("code",[e._v("result3")]),e._v(" isn’t displayed until the end of "),t("code",[e._v("main()")]),e._v(". This happens because evaluating "),t("code",[e._v("result3")]),e._v(" calls "),t("code",[e._v("println()")]),e._v(", and the evaluation occurs when "),t("code",[e._v("result3")]),e._v(" is defined.")]),e._v(" "),t("p",[e._v("Notice that "),t("code",[e._v("a")]),e._v(" is defined inside the block of code for "),t("code",[e._v("result2")]),e._v(". The result of the last expression becomes the result of the "),t("code",[e._v("if")]),e._v(" expression; here, it’s the sum of 11 and 42. But what about "),t("code",[e._v("a")]),e._v("? Once you leave the code block (move outside the curly braces), you can’t access "),t("code",[e._v("a")]),e._v(". It is "),t("em",[e._v("temporary")]),e._v(" and is discarded once you exit the "),t("em",[e._v("scope")]),e._v(" of that block.")]),e._v(" "),t("p",[e._v("The increment operator "),t("code",[e._v("i++")]),e._v(" is also an expression, even if it looks like a statement. Kotlin follows the approach used by C-like languages and provides two versions of increment and decrement operators with slightly different semantics. The prefix operator appears before the operand, as in "),t("code",[e._v("++i")]),e._v(", and returns the value after the increment happens. You can read it as “first do the increment, then return the resulting value.” The postfix operator is placed after the operand, as in "),t("code",[e._v("i++")]),e._v(", and returns the value of "),t("code",[e._v("i")]),e._v(" before the increment occurs. You can read it as “first produce the result, then do the increment.”")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ExpressionsStatements/PostfixVsPrefix.kt\n\nfun main() {\n  var i = 10\n  println(i++)\n  println(i)\n  var j = 20\n  println(++j)\n  println(j)\n}\n/* Output:\n10\n11\n21\n21\n*/\n")])])]),t("p",[e._v("The decrement operator also has two versions: "),t("code",[e._v("--i")]),e._v(" and "),t("code",[e._v("i--")]),e._v(". Using increment and decrement operators within other expressions is discouraged because it can produce confusing code:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ExpressionsStatements/Confusing.kt\n\nfun main() {\n  var i = 1\n  println(i++ + ++i)\n}\n")])])]),t("p",[e._v("Try to guess what the output will be, then check it.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);