(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{393:function(e,t,a){"use strict";a.r(t);var n=a(44),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"附录-b-java-互操作性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附录-b-java-互操作性"}},[e._v("#")]),e._v(" 附录 B：Java 互操作性")]),e._v(" "),a("blockquote",[a("p",[e._v("This appendix describes issues and techniques for interfacing between Kotlin and Java.")])]),e._v(" "),a("p",[e._v("An essential Kotlin design goal is to create a seamless experience for Java programmers. If you want to slowly migrate to Kotlin, you can easily start by sprinkling bits of Kotlin into your existing Java project. This way you can write new Kotlin code atop your Java base, benefiting from Kotlin language features without being forced to rewrite Java code when it doesn’t make sense.")]),e._v(" "),a("p",[e._v("Not only is it easy to call Java code from Kotlin, it’s also straightforward to call Kotlin code within a Java program.")]),e._v(" "),a("h3",{attrs:{id:"calling-java-from-kotlin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#calling-java-from-kotlin"}},[e._v("#")]),e._v(" Calling Java from Kotlin")]),e._v(" "),a("p",[e._v("To use a Java class from Kotlin, import it, create an instance, and call a function, just as you would in Java. Here, we use "),a("code",[e._v("java.util.Random()")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/Random.kt\nimport atomictest.eq\nimport java.util.Random\n\nfun main() {\n  val rand = Random(47)\n  rand.nextInt(100) eq 58\n}\n")])])]),a("p",[e._v("As with creating any instance in Kotlin, you don’t need Java’s "),a("code",[e._v("new")]),e._v(". A class from a Java library works like a native Kotlin class.")]),e._v(" "),a("p",[e._v("JavaBean-style getters and setters in a Java class become properties in Kotlin:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/Chameleon.java\npackage interoperability;\nimport java.io.Serializable;\n\npublic\nclass Chameleon implements Serializable {\n  private int size;\n  private String color;\n  public int getSize() {\n    return size;\n  }\n  public void setSize(int newSize) {\n    size = newSize;\n  }\n  public String getColor() {\n    return color;\n  }\n  public void setColor(String newColor) {\n    color = newColor;\n  }\n}\n")])])]),a("p",[e._v("When working with Java, the package name must be identical (including case) to the directory name. Java package names typically contain only lowercase letters. To conform to this convention, this appendix uses only lowercase letters in the "),a("code",[e._v("interoperability")]),e._v(" example subdirectory name.")]),e._v(" "),a("p",[e._v("The imported "),a("code",[e._v("Chameleon")]),e._v(" class works like a Kotlin class with properties:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/UseBeanClass.kt\nimport interoperability.Chameleon\nimport atomictest.eq\n\nfun main() {\n  val chameleon = Chameleon()\n  chameleon.size = 1\n  chameleon.size eq 1\n  chameleon.color = "green"\n  chameleon.color eq "green"\n  chameleon.color = "turquoise"\n  chameleon.color eq "turquoise"\n}\n')])])]),a("p",[e._v("Extension functions are especially helpful when you use an existing Java library that lacks needed member functions. For example, we can add an "),a("code",[e._v("adjustToTemperature()")]),e._v(" operation to "),a("code",[e._v("Chameleon")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/ExtensionsToJavaClass.kt\npackage interop\nimport interoperability.Chameleon\nimport atomictest.eq\n\nfun Chameleon.adjustToTemperature(\n  isHot: Boolean\n) {\n  color = if (isHot) "grey" else "black"\n}\n\nfun main() {\n  val chameleon = Chameleon()\n  chameleon.size = 2\n  chameleon.size eq 2\n  chameleon.adjustToTemperature(isHot = true)\n  chameleon.color eq "grey"\n}\n')])])]),a("p",[e._v("The Kotlin standard library contains many extensions for classes from the Java standard library such as "),a("code",[e._v("List")]),e._v(" and "),a("code",[e._v("String")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"calling-kotlin-from-java"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#calling-kotlin-from-java"}},[e._v("#")]),e._v(" Calling Kotlin from Java")]),e._v(" "),a("p",[e._v("Kotlin produces libraries that are usable from Java. For the Java programmer, a Kotlin library looks like a Java library.")]),e._v(" "),a("p",[e._v("Because everything in Java is a class, let’s start with a Kotlin class containing a property and a function:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/KotlinClass.kt\npackage interop\n\nclass Basic {\n  var property1 = 1\n  fun value() = property1 * 10\n}\n")])])]),a("p",[e._v("If you import this class into Java, it looks like an ordinary Java class:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/UsingKotlinClass.java\npackage interoperability;\nimport interop.Basic;\nimport static atomictest.AtomicTestKt.eq;\n\npublic class UsingKotlinClass {\n  public static void main(String[] args) {\n    Basic b = new Basic();\n    eq(b.getProperty1(), 1);\n    b.setProperty1(12);\n    eq(b.value(), 120);\n  }\n}\n")])])]),a("p",[a("code",[e._v("property1")]),e._v(" becomes a "),a("code",[e._v("private")]),e._v(" field containing JavaBean-style getters and setters. The "),a("code",[e._v("value()")]),e._v(" member function becomes a Java method with the same name.")]),e._v(" "),a("p",[e._v("We have also imported "),a("code",[e._v("AtomicTest")]),e._v(", which requires additional ceremony in Java: we must import it using the "),a("code",[e._v("static")]),e._v(" keyword and give the package name. "),a("code",[e._v("eq()")]),e._v(" can only be called as an ordinary function because Java doesn’t support infix notation.")]),e._v(" "),a("p",[e._v("If a Kotlin class is in the same package as Java code, you don’t need to import it:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/KotlinDataClass.kt\npackage interoperability\n\ndata class Staff(\n  var name: String,\n  var role: String\n)\n")])])]),a("p",[a("code",[e._v("data")]),e._v(" classes generate extra member functions like "),a("code",[e._v("equals()")]),e._v(", "),a("code",[e._v("hashCode()")]),e._v(" and "),a("code",[e._v("toString()")]),e._v(", all of which work seamlessly within Java. At the end of "),a("code",[e._v("main()")]),e._v(", we verify the implementations of "),a("code",[e._v("equals()")]),e._v(" and "),a("code",[e._v("hashCode()")]),e._v(" by placing a "),a("code",[e._v("Data")]),e._v(" object into a "),a("code",[e._v("HashMap")]),e._v(", then retrieving it:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/UseDataClass.java\npackage interoperability;\nimport java.util.HashMap;\nimport static atomictest.AtomicTestKt.eq;\n\npublic class UseDataClass {\n  public static void main(String[] args) {\n    Staff e = new Staff(\n      "Fluffy", "Office Manager");\n    eq(e.getRole(), "Office Manager");\n    e.setName("Uranus");\n    e.setRole("Assistant");\n    eq(e,\n      "Staff(name=Uranus, role=Assistant)");\n\n    // Call copy() from the data class:\n    Staff cf = e.copy("Cornfed", "Sidekick");\n    eq(cf,\n      "Staff(name=Cornfed, role=Sidekick)");\n\n    HashMap<Staff, String> hm =\n      new HashMap<>();\n    // Employees work as hash keys:\n    hm.put(e, "Cheerful");\n    eq(hm.get(e), "Cheerful");\n  }\n}\n')])])]),a("p",[e._v("If you use the command line to run Java code that incorporates Kotlin code, you must include "),a("code",[e._v("kotlin-runtime.jar")]),e._v(" as a dependency, otherwise you’ll get runtime exceptions complaining that some of the library utility classes are not found. IntelliJ IDEA automatically includes "),a("code",[e._v("kotlin-runtime.jar")]),e._v(".")]),e._v(" "),a("p",[e._v("Kotlin top-level functions map to "),a("code",[e._v("static")]),e._v(" methods in a Java class that takes its name from the Kotlin file:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/TopLevelFunction.kt\npackage interop\n\nfun hi() = "Hello!"\n')])])]),a("p",[e._v("To import, specify the class name generated by Kotlin. This name must also be used when calling the "),a("code",[e._v("static")]),e._v(" method:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/CallTopLevelFunction.java\npackage interoperability;\nimport interop.TopLevelFunctionKt;\nimport static atomictest.AtomicTestKt.eq;\n\npublic class CallTopLevelFunction {\n  public static void main(String[] args) {\n    eq(TopLevelFunctionKt.hi(), "Hello!");\n  }\n}\n')])])]),a("p",[e._v("If you don’t want to qualify "),a("code",[e._v("hi()")]),e._v(" with the package name, use "),a("code",[e._v("import static")]),e._v(" as we do with "),a("code",[e._v("AtomicTest")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/CallTopLevelFunction2.java\npackage interoperability;\nimport static interop.TopLevelFunctionKt.hi;\nimport static atomictest.AtomicTestKt.eq;\n\npublic class CallTopLevelFunction2 {\n  public static void main(String[] args) {\n    eq(hi(), "Hello!");\n  }\n}\n')])])]),a("p",[e._v("If you don’t like the class name generated by Kotlin, you can change it using the "),a("code",[e._v("@JvmName")]),e._v(" annotation:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/ChangeName.kt\n@file:JvmName("Utils")\npackage interop\n\nfun salad() = "Lettuce!"\n')])])]),a("p",[e._v("Now instead of "),a("code",[e._v("ChangeNameKt")]),e._v(", we use "),a("code",[e._v("Utils")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/MakeSalad.java\npackage interoperability;\nimport interop.Utils;\nimport static atomictest.AtomicTestKt.eq;\n\npublic class MakeSalad {\n  public static void main(String[] args) {\n    eq(Utils.salad(), "Lettuce!");\n  }\n}\n')])])]),a("p",[e._v("You can find further details in the "),a("a",{attrs:{href:"https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("documentation"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"adapting-java-to-kotlin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adapting-java-to-kotlin"}},[e._v("#")]),e._v(" Adapting Java to Kotlin")]),e._v(" "),a("p",[e._v("One of Kotlin’s design goals is to take an existing Java type and adapt it to your needs. This ability is not restricted to library designers—the same logic can be applied to any external code base.")]),e._v(" "),a("p",[e._v("In [Recursion](javascript:void(0)), we created "),a("code",[e._v("Fibonacci.kt")]),e._v(" to efficiently produce Fibonacci numbers. That implementation is limited by the size of the "),a("code",[e._v("Long")]),e._v(" it returns. If you’d like to return larger values, the Java standard library includes the "),a("code",[e._v("BigInteger")]),e._v(" class. A few lines of code morphs "),a("code",[e._v("BigInteger")]),e._v(" into something that feels like a native Kotlin class:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/BigInt.kt\npackage biginteger\nimport java.math.BigInteger\n\nfun Int.toBigInteger(): BigInteger =\n  BigInteger.valueOf(toLong())\n\nfun String.toBigInteger(): BigInteger =\n  BigInteger(this)\n\noperator fun BigInteger.plus(\n  other: BigInteger\n): BigInteger = add(other)\n")])])]),a("p",[e._v("The "),a("code",[e._v("toBigInteger()")]),e._v(" extension functions converts any "),a("code",[e._v("Int")]),e._v(" or "),a("code",[e._v("String")]),e._v(" to a "),a("code",[e._v("BigInteger")]),e._v(" by calling the "),a("code",[e._v("BigInteger")]),e._v(" constructor and passing the receiver string as an argument.")]),e._v(" "),a("p",[e._v("Overloading the operator "),a("code",[e._v("BigInteger.plus()")]),e._v(" allows you to write "),a("code",[e._v("number + other")]),e._v(". This makes working with "),a("code",[e._v("BigInteger")]),e._v(" enjoyable compared to Java’s clumsy "),a("code",[e._v("number.plus(other)")]),e._v(".")]),e._v(" "),a("p",[e._v("Using "),a("code",[e._v("BigInteger")]),e._v(", "),a("code",[e._v("Recursion/Fibonacci.kt")]),e._v(" easily converts to produce much larger results:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/BigFibonacci.kt\npackage interop\nimport atomictest.eq\nimport java.math.BigInteger\nimport java.math.BigInteger.ONE\nimport java.math.BigInteger.ZERO\n\nfun fibonacci(n: Int): BigInteger {\n  tailrec fun fibonacci(\n    n: Int,\n    current: BigInteger,\n    next: BigInteger\n  ): BigInteger {\n    if (n == 0) return current\n    return fibonacci(\n      n - 1, next, current + next)   // [1]\n  }\n  return fibonacci(n, ZERO, ONE)\n}\n\nfun main() {\n  (0..7).map { fibonacci(it) } eq\n  "[0, 1, 1, 2, 3, 5, 8, 13]"\n  fibonacci(22) eq 17711.toBigInteger()\n  fibonacci(150) eq\n    "9969216677189303386214405760200"\n      .toBigInteger()\n}\n')])])]),a("p",[e._v("All "),a("code",[e._v("Long")]),e._v("s were replaced with "),a("code",[e._v("BigInteger")]),e._v(". In "),a("code",[e._v("main()")]),e._v(", you see both "),a("code",[e._v("Int")]),e._v(" and "),a("code",[e._v("String")]),e._v(" converted to "),a("code",[e._v("BigInteger")]),e._v(" using different "),a("code",[e._v("toBigInteger()")]),e._v(" extension properties. In line "),a("strong",[e._v("[1]")]),e._v(" we use the "),a("code",[e._v("plus")]),e._v(" operator to find the sum "),a("code",[e._v("current + next")]),e._v("; this is identical to the original version using "),a("code",[e._v("Long")]),e._v(".")]),e._v(" "),a("p",[a("code",[e._v("fibonacci(150)")]),e._v(" overflows the "),a("code",[e._v("Recursion/Fibonacci.kt")]),e._v(" version, but works fine after the conversion to "),a("code",[e._v("BigInteger")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"java-checked-exceptions-kotlin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-checked-exceptions-kotlin"}},[e._v("#")]),e._v(" Java Checked Exceptions & Kotlin")]),e._v(" "),a("p",[e._v("Java was predominantly patterned after the C++ language, which allowed you to specify the exceptions that a function might throw. The Java designers decided to go one step further and "),a("em",[e._v("force")]),e._v(" anyone calling that function to catch every specified exception. This seemed like a good idea at the time, and thus was born "),a("em",[e._v("checked exceptions")]),e._v("—an experiment that, to our knowledge, has not been repeated in subsequent programming languages.")]),e._v(" "),a("p",[e._v("Here’s how Java forces you to catch checked exceptions in the process of opening, reading and closing a file. We only provide the basics to show the checked exceptions; you must actually write more complex code to correctly solve this problem in Java:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/JavaChecked.java\npackage interoperability;\nimport java.io.*;\nimport java.nio.file.*;\nimport static atomictest.AtomicTestKt.eq;\n\npublic class JavaChecked {\n  // Build path to current source file, based\n  // on directory where Gradle is invoked:\n  static Path thisFile = Paths.get(\n    "DataFiles", "file_wubba.txt");\n  public static void main(String[] args) {\n    BufferedReader source = null;\n    try {\n      source = new BufferedReader(\n        new FileReader(thisFile.toFile()));\n    } catch(FileNotFoundException e) {\n      // Recover from file-open error\n    }\n    try {\n      String first = source.readLine();\n      eq(first, "wubba lubba dub dub");\n    } catch(IOException e) {\n      // Recover from read() error\n    }\n    try {\n      source.close();\n    } catch(IOException e) {\n      // Recover from close() error\n    }\n  }\n}\n')])])]),a("p",[e._v("Each of the above operations involves checked exceptions and must be placed inside a "),a("code",[e._v("try")]),e._v(" block or Java produces compile-time errors for uncaught exceptions.")]),e._v(" "),a("p",[e._v("The only reason to "),a("code",[e._v("catch")]),e._v(" an exception is if you can somehow recover from the problem. If it’s not something you can fix, there’s no point in writing a "),a("code",[e._v("catch")]),e._v(" clause for that exception—just let it become an error report. In the above examples, recovery from the errors seems dubious, but you’re still forced to write the "),a("code",[e._v("try")]),e._v("-"),a("code",[e._v("catch")]),e._v(" blocks.")]),e._v(" "),a("p",[e._v("Let’s rewrite this example in Kotlin:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/KotlinChecked.kt\nimport atomictest.eq\nimport java.io.File\n\nfun main() {\n  File("DataFiles/file_wubba.txt")\n    .readLines()[0] eq\n    "wubba lubba dub dub"\n}\n')])])]),a("p",[e._v("Kotlin allows us to reduce the operation to a single line of code because it adds extension functions to the Java "),a("code",[e._v("File")]),e._v(" class. At the same time, Kotlin eliminates the checked exceptions. If we wanted, we could surround intermediate operations with "),a("code",[e._v("try")]),e._v("-"),a("code",[e._v("catch")]),e._v(" blocks, but Kotlin does not enforce checked exceptions. This provides error reporting without compelling you to write the additional noisy code.")]),e._v(" "),a("p",[e._v("Java libraries often use checked exceptions in situations that are outside the programmer’s control and are typically unrecoverable. In these cases, it’s best to catch the exception at the top level and restart the process, if possible. Requiring all intermediate levels to pass the exception only adds cognitive overhead when trying to understand the code.")]),e._v(" "),a("p",[e._v("If you’re writing Kotlin code that is called from Java and you must specify a checked exception, Kotlin provides the "),a("code",[e._v("@Throws")]),e._v(" annotation to give this information to the Java caller:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/AnnotateThrows.kt\npackage interop\nimport java.io.IOException\n\n@Throws(IOException::class)\nfun hasCheckedException() {\n  throw IOException()\n}\n")])])]),a("p",[e._v("Here’s how "),a("code",[e._v("hasCheckedException()")]),e._v(" is called from Java:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/CatchChecked.java\npackage interoperability;\nimport interop.AnnotateThrowsKt;\nimport java.io.IOException;\nimport static atomictest.AtomicTestKt.eq;\n\npublic class CatchChecked {\n  public static void main(String[] args) {\n    try {\n      AnnotateThrowsKt.hasCheckedException();\n    } catch(IOException e) {\n      eq(e, "java.io.IOException");\n    }\n  }\n}\n')])])]),a("p",[e._v("If you don’t handle the exception, the Java compiler issues an error message.")]),e._v(" "),a("p",[e._v("Although Kotlin includes language support for exception handling, it tends to emphasize error reporting and reserves exception handling for those rare situations where you can actually recover from a problem (almost exclusively I/O operations).")]),e._v(" "),a("h3",{attrs:{id:"nullable-types-java"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nullable-types-java"}},[e._v("#")]),e._v(" Nullable Types & Java")]),e._v(" "),a("p",[e._v("Kotlin ensures that "),a("em",[e._v("pure")]),e._v(" Kotlin code has no "),a("code",[e._v("null")]),e._v(" errors, but when you call into Java, you have no such guarantees. In the following Java code, "),a("code",[e._v("get()")]),e._v(" sometimes returns "),a("code",[e._v("null")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/JTool.java\npackage interoperability;\n\npublic class JTool {\n  public static JTool get(String s) {\n    if(s == null) return null;\n    return new JTool();\n  }\n  public String method() {\n    return "Success";\n  }\n}\n')])])]),a("p",[e._v("To use "),a("code",[e._v("JTool")]),e._v(" within Kotlin, you must know how "),a("code",[e._v("get()")]),e._v(" behaves. You have three choices, shown here in the definitions of "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(" and "),a("code",[e._v("c")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/PlatformTypes.kt\npackage interop\nimport interoperability.JTool\nimport atomictest.eq\n\nobject KotlinCode {\n  val a: JTool? = JTool.get("")  // [1]\n  val b: JTool = JTool.get("")   // [2]\n  val c = JTool.get("")          // [3]\n}\n\nfun main() {\n  with(KotlinCode) {\n    a?.method() eq "Success"     // [4]\n    b.method() eq "Success"\n    c.method() eq "Success"      // [5]\n    ::a.returnType eq\n      "interoperability.JTool?"\n    ::b.returnType eq\n      "interoperability.JTool"\n    ::c.returnType eq\n      "interoperability.JTool!"  // [6]\n  }\n}\n')])])]),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" Specify the type as nullable.")]),e._v(" "),a("li",[a("strong",[e._v("[2]")]),e._v(" Specify the type as non-nullable.")]),e._v(" "),a("li",[a("strong",[e._v("[3]")]),e._v(" Use type inference.")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("with()")]),e._v(" in "),a("code",[e._v("main()")]),e._v(" allows us to refer to "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(" and "),a("code",[e._v("c")]),e._v(" without the "),a("code",[e._v("KotlinCode")]),e._v(" qualification. Because the identifiers are inside an "),a("code",[e._v("object")]),e._v(", we can use member reference syntax and the "),a("code",[e._v("returnType")]),e._v(" property to determine their types.")]),e._v(" "),a("p",[e._v("To initialize "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(" and "),a("code",[e._v("c")]),e._v(", we pass a non-"),a("code",[e._v("null String")]),e._v(" to "),a("code",[e._v("get()")]),e._v(", so "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(" and "),a("code",[e._v("c")]),e._v(" all end up with non-"),a("code",[e._v("null")]),e._v(" references and each one can successfully call "),a("code",[e._v("method()")]),e._v(".")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("[4]")]),e._v(" Because "),a("code",[e._v("a")]),e._v(" is nullable, it must use "),a("code",[e._v("?.")]),e._v(" during member function calls.")]),e._v(" "),a("li",[a("strong",[e._v("[5]")]),e._v(" "),a("code",[e._v("c")]),e._v(" behaves like a non-nullable reference and can be dereferenced without any additional checks.")]),e._v(" "),a("li",[a("strong",[e._v("[6]")]),e._v(" Notice that "),a("code",[e._v("c")]),e._v(" returns neither a nullable type nor a non-nullable type, but something entirely different: "),a("code",[e._v("JTool!")]),e._v(".")])]),e._v(" "),a("p",[a("code",[e._v("Type!")]),e._v(" is Kotlin’s "),a("em",[e._v("platform type")]),e._v(", and has no notation—you can’t write it into your code. It is used whenever Kotlin must infer a type outside its domain.")]),e._v(" "),a("p",[e._v("If a type comes from Java, accessing it can produce a "),a("code",[e._v("null")]),e._v(" pointer exception (NPE). Here’s what happens when "),a("code",[e._v("JTool.get()")]),e._v(" returns a "),a("code",[e._v("null")]),e._v(" reference:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/NPEOnPlatformType.kt\nimport interoperability.JTool\nimport atomictest.*\n\nfun main() {\n  val xn: JTool? = JTool.get(null)  // [1]\n  xn?.method() eq null\n\n  val yn = JTool.get(null)          // [2]\n  yn?.method() eq null              // [3]\n  capture {\n    yn.method()                     // [4]\n  } contains listOf("NullPointerException")\n\n  capture {\n    val zn: JTool = JTool.get(null) // [5]\n  } eq "NullPointerException: " +\n    "JTool.get(null) must not be null"\n}\n')])])]),a("p",[e._v("When you call a Java method like "),a("code",[e._v("JTool.get()")]),e._v(" inside Kotlin, its return value (unless annotated as explained in the next section) is a platform type, which in this case is "),a("code",[e._v("JTool!")]),e._v(".")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" Because "),a("code",[e._v("xn")]),e._v(" is of the nullable type "),a("code",[e._v("JTool?")]),e._v(", it can successfully receive a "),a("code",[e._v("null")]),e._v(". Assigning to a nullable type is safe, because Kotlin forces you to test for "),a("code",[e._v("null")]),e._v(" using "),a("code",[e._v("?.")]),e._v(" when calling "),a("code",[e._v("method()")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("[2]")]),e._v(" At the point of definition, "),a("code",[e._v("yn")]),e._v(" successfully receives the "),a("code",[e._v("null")]),e._v(" without complaint because Kotlin infers it to be the platform type "),a("code",[e._v("JTool!")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("[3]")]),e._v(" You can dereference "),a("code",[e._v("yn")]),e._v(" by using a safe-access call "),a("code",[e._v("?.")]),e._v(", which in this case returns "),a("code",[e._v("null")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("[4]")]),e._v(" However, using "),a("code",[e._v("?.")]),e._v(" is not required. You can simply dereference "),a("code",[e._v("yn")]),e._v(". In this case you get a "),a("code",[e._v("NullPointerException")]),e._v(" without any helpful message.")]),e._v(" "),a("li",[a("strong",[e._v("[5]")]),e._v(" Assigning to a non-nullable type can produce an NPE. Kotlin checks for nullity at the point of assignment. The initialization of "),a("code",[e._v("zn")]),e._v(" fails because the declared type "),a("code",[e._v("JTool")]),e._v(" promises that "),a("code",[e._v("zn")]),e._v(" is not nullable, but it receives a "),a("code",[e._v("null")]),e._v(" which produces a "),a("code",[e._v("NullPointerException")]),e._v(", this time with a helpful message.")])]),e._v(" "),a("p",[e._v("The exception message contains detailed information about the expression that produced the "),a("code",[e._v("null")]),e._v(": "),a("code",[e._v("NullPointerException: JTool.get(null) must not be null")]),e._v(". Even though it’s a runtime exception, the comprehensive error message makes the problem much easier than fixing a regular NPE.")]),e._v(" "),a("p",[e._v("A platform type contains the "),a("em",[e._v("least")]),e._v(" amount of information available for that type. In this case, it only tells you that the type is "),a("code",[e._v("JTool")]),e._v(". It might or might not be nullable—when using an inferred platform type you simply don’t know.")]),e._v(" "),a("p",[e._v("You can’t explicitly declare a platform type (e.g. "),a("code",[e._v("JTool!")]),e._v("). You can only observe a platform type in error messages, or when you display the inferred type as in "),a("code",[e._v("PlatformTypes.kt")]),e._v(", or by checking the type within the IDE.")]),e._v(" "),a("p",[e._v("When working on a mixed Kotlin and Java project, you may or may not have control over the Java code base. When using an external Java library, you can’t modify the source code, so you must work with platform types.")]),e._v(" "),a("p",[e._v("Platform types provide seamless Java interoperability, and maintain the consistency of type inference. However, don’t rely on them. The proper strategy when calling un-annotated Java code is to avoid type inference, and instead understand whether or not the code you are calling can produce "),a("code",[e._v("null")]),e._v("s.")]),e._v(" "),a("h3",{attrs:{id:"nullability-annotations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nullability-annotations"}},[e._v("#")]),e._v(" Nullability Annotations")]),e._v(" "),a("p",[e._v("If you control the Java code base, you can add "),a("em",[e._v("nullability annotations")]),e._v(" to the Java code and avoid subtle NPE errors. "),a("code",[e._v("@Nullable")]),e._v(" and "),a("code",[e._v("@NotNull")]),e._v(" tell Kotlin to treat a Java type as nullable or non-nullable, respectively. Here we add Kotlin nullability annotations to "),a("code",[e._v("JTool.java")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/AnnotatedJTool.java\npackage interoperability;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\npublic class AnnotatedJTool {\n  @Nullable\n  public static JTool\n  getUnsafe(@Nullable String s) {\n    if(s == null) return null;\n    return getSafe(s);\n  }\n  @NotNull\n  public static JTool\n  getSafe(@NotNull String s) {\n    return new JTool();\n  }\n  public String method() {\n    return "Success";\n  }\n}\n')])])]),a("p",[e._v("Applying an annotation to a Java parameter affects only that parameter. Applying an annotation in front of a Java method modifies the return type.")]),e._v(" "),a("p",[e._v("When you call "),a("code",[e._v("getUnsafe()")]),e._v(" and "),a("code",[e._v("getSafe()")]),e._v(" in Kotlin, Kotlin treats the "),a("code",[e._v("AnnotatedJTool")]),e._v(" member functions as native Kotlin nullable or non-nullable:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/AnnotatedJava.kt\npackage interop\nimport interoperability.AnnotatedJTool\nimport atomictest.eq\n\nobject KotlinCode2 {\n  val a = AnnotatedJTool.getSafe("")\n  // Doesn\'t compile:\n  // val b = AnnotatedJTool.getSafe(null)\n  val c = AnnotatedJTool.getUnsafe("")\n  val d = AnnotatedJTool.getUnsafe(null)\n}\n\nfun main() {\n  with(KotlinCode2) {\n    ::a.returnType eq\n      "interoperability.JTool"\n    ::c.returnType eq\n      "interoperability.JTool?"\n    ::d.returnType eq\n      "interoperability.JTool?"\n  }\n}\n')])])]),a("p",[a("code",[e._v("@NotNull JTool")]),e._v(" is transformed to Kotlin’s non-nullable type "),a("code",[e._v("JTool")]),e._v(", and the annotated "),a("code",[e._v("@Nullable JTool")]),e._v(" is transformed to Kotlin’s "),a("code",[e._v("JTool?")]),e._v(". You can see this in the types shown in "),a("code",[e._v("main()")]),e._v(" for "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("c")]),e._v(", and "),a("code",[e._v("d")]),e._v(".")]),e._v(" "),a("p",[e._v("You can’t pass a nullable argument when a non-nullable argument is expected, even if it’s a Java type annotated with "),a("code",[e._v("@NotNull")]),e._v(", so Kotlin won’t compile "),a("code",[e._v("AnnotatedJTool.getSafe(null)")]),e._v(".")]),e._v(" "),a("p",[e._v("Different kinds of nullability annotations are supported, using different names:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("@Nullable")]),e._v(" and "),a("code",[e._v("@CheckForNull")]),e._v(" are specified by the JSR-305 standard.")]),e._v(" "),a("li",[a("code",[e._v("@Nullable")]),e._v(" and "),a("code",[e._v("@NonNull")]),e._v(" are used in Android.")]),e._v(" "),a("li",[a("code",[e._v("@Nullable")]),e._v(" and "),a("code",[e._v("@NotNull")]),e._v(" are supported by JetBrains tools.")]),e._v(" "),a("li",[e._v("There are others. You can find the full list in the Kotlin "),a("a",{attrs:{href:"https://kotlinlang.org/docs/java-interop.html#nullability-annotations",target:"_blank",rel:"noopener noreferrer"}},[e._v("documentation"),a("OutboundLink")],1),e._v(".")])]),e._v(" "),a("p",[e._v("Kotlin detects default nullability annotations for a Java package or class, as specified in the JSR-305 standard. If it’s "),a("code",[e._v("@NotNull")]),e._v(" by default, you should explicitly specify only "),a("code",[e._v("@Nullable")]),e._v(" annotations. If it’s "),a("code",[e._v("@Nullable")]),e._v(" by default, you should explicitly specify only "),a("code",[e._v("@NotNull")]),e._v(" annotations. The "),a("a",{attrs:{href:"https://kotlinlang.org/docs/java-interop.html#jsr-305-support",target:"_blank",rel:"noopener noreferrer"}},[e._v("documentation"),a("OutboundLink")],1),e._v(" contains the technical details for choosing the default annotation.")]),e._v(" "),a("p",[e._v("If you develop mixed Kotlin and Java projects, your applications will be safer if you use nullability annotations in your Java code.")]),e._v(" "),a("h3",{attrs:{id:"collections-java"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collections-java"}},[e._v("#")]),e._v(" Collections & Java")]),e._v(" "),a("p",[e._v("This book doesn’t require Java knowledge. However, when you write code in Kotlin for the Java Virtual Machine (JVM), it’s helpful to be familiar with the Java standard collections library, because Kotlin uses it to create its own collections.")]),e._v(" "),a("p",[e._v("The Java collections library is a set of classes and interfaces that implement collection data structures, such as lists, sets and maps. These data structures usually have clear and simple interfaces, but for speed may have complicated implementations.")]),e._v(" "),a("p",[e._v("New languages typically create their own collections library from scratch. For example, the Scala language has its own collections library which in many ways surpasses the Java collections library, but also makes it more challenging to mix Scala and Java.")]),e._v(" "),a("p",[e._v("Kotlin’s collections library is intentionally "),a("em",[e._v("not")]),e._v(" rewritten from scratch. Instead, it consists of improvements atop the Java collections library. For example, when you create a mutable "),a("code",[e._v("List")]),e._v(", you’re actually using Java’s "),a("code",[e._v("ArrayList")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/HiddenArrayList.kt\nimport atomictest.eq\n\nfun main() {\n  val list = mutableListOf(1, 2, 3)\n  list.javaClass.name eq\n    "java.util.ArrayList"\n}\n')])])]),a("p",[e._v("For seamless interoperability with Java code, Kotlin uses the interfaces from the Java standard library, and often the same implementations. This produces three benefits:")]),e._v(" "),a("ol",[a("li",[e._v("Kotlin code can easily mix with Java code. No additional conversion is required when passing Kotlin collections to Java code.")]),e._v(" "),a("li",[e._v("Years of performance tuning in the Java standard library is automatically available to Kotlin programmers.")]),e._v(" "),a("li",[e._v("The standard library included with a Kotlin application is small, because it uses Java collections rather than defining its own. The Kotlin standard library consists primarily of extension functions that improve the Java collections.")])]),e._v(" "),a("p",[e._v("Kotlin also fixes a design problem. In Java all collection interfaces are mutable. For example, "),a("code",[e._v("java.util.List")]),e._v(" has methods "),a("code",[e._v("add()")]),e._v(" and "),a("code",[e._v("remove()")]),e._v(" that modify the "),a("code",[e._v("List")]),e._v(". As we’ve shown throughout this book, mutability is the source of a significant number of programming problems. Thus, in Kotlin, the default "),a("code",[e._v("Collection")]),e._v(" type is read-only:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/ReadOnlyByDefault.kt\npackage interop\n\ndata class Animal(val name: String)\n\ninterface Zoo {\n  fun viewAnimals(): Collection<Animal>\n}\n\nfun visitZoo(zoo: Zoo) {\n  val animals = zoo.viewAnimals()\n  // Compile-time error:\n  // animals.add(Animal("Grumpy Cat"))\n}\n')])])]),a("p",[e._v("Read-only collections are safer and more bug-free because they prevent accidental modification.")]),e._v(" "),a("p",[e._v("Java provides a partial solution for collection immutability: when returning a collection you can place it inside a special wrapper that throws an exception for any attempt to modify the underlying collection. This doesn’t produce static type checking, but can still prevent subtle bugs. However, you must remember to wrap the collection to make it read-only, whereas in Kotlin you must be explicit when you "),a("em",[e._v("want")]),e._v(" a mutable collection.")]),e._v(" "),a("p",[e._v("Kotlin has separate interfaces for mutable and read-only collections:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Collection")]),e._v("/"),a("code",[e._v("MutableCollection")])]),e._v(" "),a("li",[a("code",[e._v("List")]),e._v("/"),a("code",[e._v("MutableList")])]),e._v(" "),a("li",[a("code",[e._v("Set")]),e._v("/"),a("code",[e._v("MutableSet")])]),e._v(" "),a("li",[a("code",[e._v("Map")]),e._v("/"),a("code",[e._v("MutableMap")])])]),e._v(" "),a("p",[e._v("These duplicate the interfaces from the Java standard library:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("java.util.Collection")])]),e._v(" "),a("li",[a("code",[e._v("java.util.List")])]),e._v(" "),a("li",[a("code",[e._v("java.util.Set")])]),e._v(" "),a("li",[a("code",[e._v("java.util.Map")])])]),e._v(" "),a("p",[e._v("In Kotlin, as in Java, "),a("code",[e._v("Collection")]),e._v(" is a supertype for both "),a("code",[e._v("List")]),e._v(" and "),a("code",[e._v("Set")]),e._v(". "),a("code",[e._v("MutableCollection")]),e._v(" extends "),a("code",[e._v("Collection")]),e._v(" and is a supertype of "),a("code",[e._v("MutableList")]),e._v(" and "),a("code",[e._v("MutableSet")]),e._v(". Here’s the basic structure:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/CollectionStructure.kt\npackage collectionstructure\n\ninterface Collection<E>\ninterface List<E>: Collection<E>\ninterface Set<E>: Collection<E>\ninterface Map<K, V>\ninterface MutableCollection<E>\ninterface MutableList<E>:\n  List<E>, MutableCollection<E>\ninterface MutableSet<E>:\n  Set<E>, MutableCollection<E>\ninterface MutableMap<K, V>: Map<K, V>\n")])])]),a("p",[e._v("For simplicity, we show only the names and not the full declarations from the Kotlin standard library.")]),e._v(" "),a("p",[e._v("Kotlin mutable collections match their Java counterparts. If you compare "),a("code",[e._v("MutableCollection")]),e._v(" from "),a("code",[e._v("kotlin.collections")]),e._v(" with "),a("code",[e._v("java.util.List")]),e._v(", you’ll see that they declare the same member functions ("),a("em",[e._v("methods")]),e._v(", in Java terminology). Kotlin’s "),a("code",[e._v("Collection")]),e._v(", "),a("code",[e._v("List")]),e._v(", "),a("code",[e._v("Set")]),e._v(" and "),a("code",[e._v("Map")]),e._v(" also duplicate Java’s interfaces, but without any mutation methods.")]),e._v(" "),a("p",[e._v("Both "),a("code",[e._v("kotlin.collections.List")]),e._v(" and "),a("code",[e._v("kotlin.collections.MutableList")]),e._v(" are visible from Java as "),a("code",[e._v("java.util.List")]),e._v(". These interfaces are special: they exist only in Kotlin, but at the bytecode level they are both replaced with Java’s "),a("code",[e._v("List")]),e._v(".")]),e._v(" "),a("p",[e._v("A Kotlin "),a("code",[e._v("List")]),e._v(" can be cast to a Java "),a("code",[e._v("List")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/JavaList.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 2, 3)\n  (list is java.util.List<*>) eq true\n}\n")])])]),a("p",[e._v("This code produces a warning:")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("This class shouldn’t be used in Kotlin.")])]),e._v(" "),a("li",[a("em",[e._v("Use kotlin.collections.List or kotlin.collections.MutableList instead.")])])]),e._v(" "),a("p",[e._v("This is a reminder to use Kotlin’s interfaces, not Java’s, when programming in Kotlin.")]),e._v(" "),a("p",[e._v("Keep in mind that read-only is not the same as immutable. A collection cannot be changed using a read-only reference, but it can still change:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// interoperability/ReadOnlyCollections.kt\nimport atomictest.eq\n\nfun main() {\n  val mutable = mutableListOf(1, 2, 3)\n  // Read-only reference to a mutable list:\n  val list: List<Int> = mutable\n  mutable += 4\n  // list has changed:\n  list eq "[1, 2, 3, 4]"\n}\n')])])]),a("p",[e._v("Here, the read-only "),a("code",[e._v("list")]),e._v(" references a "),a("code",[e._v("MutableList")]),e._v(", which can then be changed by manipulating "),a("code",[e._v("mutable")]),e._v(". Because all Java collections are mutable, Java code can modify a read-only Kotlin collection, even if you pass it via a read-only reference.")]),e._v(" "),a("p",[e._v("Kotlin collections don’t produce full safety, but provide a good compromise between having a better library and maintaining compatibility with Java.")]),e._v(" "),a("h3",{attrs:{id:"java-primitive-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-primitive-types"}},[e._v("#")]),e._v(" Java Primitive Types")]),e._v(" "),a("p",[e._v("In Kotlin, you call a constructor to create an object, but in Java you must use "),a("code",[e._v("new")]),e._v(" to produce an object. "),a("code",[e._v("new")]),e._v(" places the resulting object on the heap. Such types are called "),a("em",[e._v("reference types")]),e._v(".")]),e._v(" "),a("p",[e._v("Creating objects on the heap can be inefficient for basic types such as numbers. For these types, Java falls back on the approach taken by C and C++: Instead of creating the variable using "),a("code",[e._v("new")]),e._v(", a non-reference “automatic” variable is created that holds the value directly. Automatic variables are placed on the stack, making them much more efficient. Such types get special treatment by the JVM and are called "),a("em",[e._v("primitive types")]),e._v(".")]),e._v(" "),a("p",[e._v("There are a fixed number of primitive types: "),a("code",[e._v("boolean")]),e._v(", "),a("code",[e._v("int")]),e._v(", "),a("code",[e._v("long")]),e._v(", "),a("code",[e._v("char")]),e._v(", "),a("code",[e._v("byte")]),e._v(", "),a("code",[e._v("short")]),e._v(", "),a("code",[e._v("float")]),e._v(" and "),a("code",[e._v("double")]),e._v(". Primitive types always contain a non-"),a("code",[e._v("null")]),e._v(" value, and they can’t be used as generic arguments. If you need to store "),a("code",[e._v("null")]),e._v(" or use such types as generic arguments, you can use the corresponding reference type defined in the Java standard library, such as "),a("code",[e._v("java.lang.Boolean")]),e._v(" or "),a("code",[e._v("java.lang.Integer")]),e._v(". These types are often called "),a("em",[e._v("wrapper types")]),e._v(" or "),a("em",[e._v("boxed types")]),e._v(" to emphasize that they only wrap the primitive value and store it on the heap.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/JavaWrapper.java\npackage interoperability;\nimport java.util.*;\n\npublic class JavaWrapper {\n  public static void main(String[] args) {\n    // Primitive type\n    int i = 10;\n    // Wrapper types\n    Integer iOrNull = null;\n    List<Integer> list = new ArrayList<>();\n  }\n}\n")])])]),a("p",[e._v("Java distinguishes between reference types and primitive types, but Kotlin does not. You use the same type "),a("code",[e._v("Int")]),e._v(" both for defining an integer "),a("code",[e._v("var")]),e._v("/"),a("code",[e._v("val")]),e._v(" or using it as a generic argument. At the JVM level, Kotlin employs the same primitive type support. When possible, Kotlin replaces "),a("code",[e._v("Int")]),e._v(" with a primitive "),a("code",[e._v("int")]),e._v(" in the bytecode. A nullable "),a("code",[e._v("Int?")]),e._v(" or "),a("code",[e._v("Int")]),e._v(" used as a generic argument can only be represented using the wrapper type:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// interoperability/KotlinWrapper.kt\npackage interop\n\nfun main() {\n  // Generates a primitive int:\n  val i = 10\n  // Generates wrapper types:\n  val iOrNull: Int? = null\n  val list: List<Int> = listOf(1, 2, 3)\n}\n")])])]),a("p",[e._v("You normally don’t need to think much about whether primitives or wrappers are generated by the Kotlin compiler, but it’s useful to know how it’s implemented on the JVM.")]),e._v(" "),a("ul",[a("li",[e._v("-")])]),e._v(" "),a("p",[e._v("The "),a("a",{attrs:{href:"https://kotlinlang.org/docs/java-interop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("documentation"),a("OutboundLink")],1),e._v(" explains more about the nuances of Kotlin/Java interoperability.")])])}),[],!1,null,null,null);t.default=o.exports}}]);