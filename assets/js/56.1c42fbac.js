(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{429:function(e,a,t){"use strict";t.r(a);var n=t(44),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"maps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#maps"}},[e._v("#")]),e._v(" Maps")]),e._v(" "),t("blockquote",[t("p",[e._v("A "),t("code",[e._v("Map")]),e._v(" connects "),t("em",[e._v("keys")]),e._v(" to "),t("em",[e._v("values")]),e._v(" and looks up a value when given a key.")])]),e._v(" "),t("p",[e._v("You create a "),t("code",[e._v("Map")]),e._v(" by providing key-value pairs to "),t("code",[e._v("mapOf()")]),e._v(". Using "),t("code",[e._v("to")]),e._v(", we separate each key from its associated value:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Maps/Maps.kt\nimport atomictest.eq\n\nfun main() {\n  val constants = mapOf(\n    "Pi" to 3.141,\n    "e" to 2.718,\n    "phi" to 1.618\n  )\n  constants eq\n    "{Pi=3.141, e=2.718, phi=1.618}"\n\n  // Look up a value from a key:\n  constants["e"] eq 2.718              // [1]\n  constants.keys eq setOf("Pi", "e", "phi")\n  constants.values eq "[3.141, 2.718, 1.618]"\n\n  var s = ""\n  // Iterate through key-value pairs:\n  for (entry in constants) {           // [2]\n    s += "${entry.key}=${entry.value}, "\n  }\n  s eq "Pi=3.141, e=2.718, phi=1.618,"\n\n  s = ""\n  // Unpack during iteration:\n  for ((key, value) in constants)      // [3]\n    s += "$key=$value, "\n  s eq "Pi=3.141, e=2.718, phi=1.618,"\n}\n')])])]),t("ul",[t("li",[t("strong",[e._v("[1]")]),e._v(" The "),t("code",[e._v("[]")]),e._v(" operator looks up a value using a key. You can produce all the keys using "),t("code",[e._v("keys")]),e._v(" and all the values using "),t("code",[e._v("values")]),e._v(". Calling "),t("code",[e._v("keys")]),e._v(" produces a "),t("code",[e._v("Set")]),e._v(" because all keys in a "),t("code",[e._v("Map")]),e._v(" must be unique, otherwise you’d have ambiguity during a lookup.")]),e._v(" "),t("li",[t("strong",[e._v("[2]")]),e._v(" Iterating through a "),t("code",[e._v("Map")]),e._v(" produces key-value pairs as map entries.")]),e._v(" "),t("li",[t("strong",[e._v("[3]")]),e._v(" You can unpack keys and values as you iterate.")])]),e._v(" "),t("p",[e._v("A plain "),t("code",[e._v("Map")]),e._v(" is read-only. Here’s a "),t("code",[e._v("MutableMap")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Maps/MutableMaps.kt\nimport atomictest.eq\n\nfun main() {\n  val m =\n    mutableMapOf(5 to "five", 6 to "six")\n  m[5] eq "five"\n  m[5] = "5ive"\n  m[5] eq "5ive"\n  m += 4 to "four"\n  m eq mapOf(5 to "5ive",\n    4 to "four", 6 to "six")\n}\n')])])]),t("p",[t("code",[e._v("map[key] = value")]),e._v(" adds or changes the "),t("code",[e._v("value")]),e._v(" associated with "),t("code",[e._v("key")]),e._v(". You can also explicitly add a pair by saying "),t("code",[e._v("map += key to value")]),e._v(".")]),e._v(" "),t("p",[t("code",[e._v("mapOf()")]),e._v(" and "),t("code",[e._v("mutableMapOf()")]),e._v(" preserve the order in which the elements are put into the "),t("code",[e._v("Map")]),e._v(". This is not guaranteed for other types of "),t("code",[e._v("Map")]),e._v(".")]),e._v(" "),t("p",[e._v("A read-only "),t("code",[e._v("Map")]),e._v(" doesn’t allow mutations:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Maps/ReadOnlyMaps.kt\nimport atomictest.eq\n\nfun main() {\n  val m = mapOf(5 to "five", 6 to "six")\n  m[5] eq "five"\n  // m[5] = "5ive" // Fails\n  // m += (4 to "four") // Fails\n  m + (4 to "four") // Doesn\'t change m\n  m eq mapOf(5 to "five", 6 to "six")\n  val m2 = m + (4 to "four")\n  m2 eq mapOf(\n    5 to "five", 6 to "six", 4 to "four")\n}\n')])])]),t("p",[e._v("The definition of "),t("code",[e._v("m")]),e._v(" creates a "),t("code",[e._v("Map")]),e._v(" associating "),t("code",[e._v("Int")]),e._v("s with "),t("code",[e._v("String")]),e._v("s. If we try to replace a "),t("code",[e._v("String")]),e._v(", Kotlin emits an error.")]),e._v(" "),t("p",[e._v("An expression with "),t("code",[e._v("+")]),e._v(" creates a new "),t("code",[e._v("Map")]),e._v(" that includes both the old elements and the new one, but doesn’t affect the original "),t("code",[e._v("Map")]),e._v(". The only way to “add” an element to a read-only "),t("code",[e._v("Map")]),e._v(" is by creating a new "),t("code",[e._v("Map")]),e._v(".")]),e._v(" "),t("p",[e._v("A "),t("code",[e._v("Map")]),e._v(" returns "),t("code",[e._v("null")]),e._v(" if it doesn’t contain an entry for a given key. If you need a result that can’t be "),t("code",[e._v("null")]),e._v(", use "),t("code",[e._v("getValue()")]),e._v(" and catch "),t("code",[e._v("NoSuchElementException")]),e._v(" if the key is missing:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Maps/GetValue.kt\nimport atomictest.*\n\nfun main() {\n  val map = mapOf(\'a\' to "attempt")\n  map[\'b\'] eq null\n  capture {\n    map.getValue(\'b\')\n  } eq "NoSuchElementException: " +\n    "Key b is missing in the map."\n  map.getOrDefault(\'a\', "??") eq "attempt"\n  map.getOrDefault(\'b\', "??") eq "??"\n}\n')])])]),t("p",[t("code",[e._v("getOrDefault()")]),e._v(" is usually a nicer alternative to "),t("code",[e._v("null")]),e._v(" or an exception.")]),e._v(" "),t("p",[e._v("You can store class instances as values in a "),t("code",[e._v("Map")]),e._v(". Here’s a map that retrieves a "),t("code",[e._v("Contact")]),e._v(" using a number "),t("code",[e._v("String")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Maps/ContactMap.kt\npackage maps\nimport atomictest.eq\n\nclass Contact(\n  val name: String,\n  val phone: String\n) {\n  override fun toString(): String {\n    return "Contact(\'$name\', \'$phone\')"\n  }\n}\n\nfun main() {\n  val miffy = Contact("Miffy", "1-234-567890")\n  val cleo = Contact("Cleo", "098-765-4321")\n  val contacts = mapOf(\n    miffy.phone to miffy,\n    cleo.phone to cleo)\n  contacts["1-234-567890"] eq miffy\n  contacts["1-111-111111"] eq null\n}\n')])])]),t("p",[e._v("It’s possible to use class instances as keys in a "),t("code",[e._v("Map")]),e._v(", but that’s trickier so we discuss it later in the book.")]),e._v(" "),t("ul",[t("li",[e._v("-")])]),e._v(" "),t("p",[t("code",[e._v("Map")]),e._v("s look like simple little databases. They are sometimes called "),t("em",[e._v("associative arrays")]),e._v(", because they associate keys with values. Although they are quite limited compared to a full-featured database, they are nonetheless remarkably useful (and far more efficient than a database).")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);