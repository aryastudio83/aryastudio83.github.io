(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{433:function(e,n,t){"use strict";t.r(n);var a=t(44),o=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"overloading"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overloading"}},[e._v("#")]),e._v(" Overloading")]),e._v(" "),t("blockquote",[t("p",[e._v("Languages without support for default arguments often use overloading to imitate that feature.")])]),e._v(" "),t("p",[e._v("The term "),t("em",[e._v("overload")]),e._v(" refers to the name of a function: You use the same name (“overload” that name) for different functions as long as the parameter lists differ. Here, we overload the member function "),t("code",[e._v("f()")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Overloading/Overloading.kt\npackage overloading\nimport atomictest.eq\n\nclass Overloading {\n  fun f() = 0\n  fun f(n: Int) = n + 2\n}\n\nfun main() {\n  val o = Overloading()\n  o.f() eq 0\n  o.f(11) eq 13\n}\n")])])]),t("p",[e._v("In "),t("code",[e._v("Overloading")]),e._v(", you see two functions with the same name, "),t("code",[e._v("f()")]),e._v(". The function’s "),t("em",[e._v("signature")]),e._v(" consists of the name, parameter list and return type. Kotlin distinguishes one function from another by comparing signatures. When overloading functions, the parameter lists must be unique—you cannot overload on return types.")]),e._v(" "),t("p",[e._v("The calls show that they are indeed different functions. A function signature also includes information about the enclosing class (or the receiver type, if it’s an extension function).")]),e._v(" "),t("p",[e._v("Note that if a class already has a member function with the same signature as an extension function, Kotlin prefers the member function. However, you can overload the member function with an extension function:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Overloading/MemberVsExtension.kt\npackage overloading\nimport atomictest.eq\n\nclass My {\n  fun foo() = 0\n}\n\nfun My.foo() = 1             // [1]\n\nfun My.foo(i: Int) = i + 2   // [2]\n\nfun main() {\n  My().foo() eq 0\n  My().foo(1) eq 3\n}\n")])])]),t("ul",[t("li",[t("strong",[e._v("[1]")]),e._v(" It’s senseless to declare an extension that duplicates a member, because it can never be called.")]),e._v(" "),t("li",[t("strong",[e._v("[2]")]),e._v(" You can overload a member function using an extension function by providing a different parameter list.")])]),e._v(" "),t("p",[e._v("Don’t use overloading to imitate default arguments. That is, don’t do this:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Overloading/WithoutDefaultArguments.kt\npackage withoutdefaultarguments\nimport atomictest.eq\n\nfun f(n: Int) = n + 373\nfun f() = f(0)\n\nfun main() {\n  f() eq 373\n}\n")])])]),t("p",[e._v("The function without parameters just calls the first function. The two functions can be replaced with a single function by using a default argument:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Overloading/WithDefaultArguments.kt\npackage withdefaultarguments\nimport atomictest.eq\n\nfun f(n: Int = 0) = n + 373\n\nfun main() {\n  f() eq 373\n}\n")])])]),t("p",[e._v("In both examples you can call the function either without an argument or by passing an integer value. Prefer the form in "),t("code",[e._v("WithDefaultArguments.kt")]),e._v(".")]),e._v(" "),t("p",[e._v("When using overloaded functions together with default arguments, calling the overloaded function searches for the “closest” match. In the following example, the "),t("code",[e._v("foo()")]),e._v(" call in "),t("code",[e._v("main()")]),e._v(" does "),t("em",[e._v("not")]),e._v(" call the first version of the function using its default argument of 99, but instead calls the second version, the one without parameters:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Overloading/OverloadedVsDefaultArg.kt\npackage overloadingvsdefaultargs\nimport atomictest.*\n\nfun foo(n: Int = 99) = trace("foo-1-$n")\n\nfun foo() {\n  trace("foo-2")\n  foo(14)\n}\n\nfun main() {\n  foo()\n  trace eq """\n    foo-2\n    foo-1-14\n  """\n}\n')])])]),t("p",[e._v("You can never utilize the default argument of "),t("code",[e._v("99")]),e._v(", because "),t("code",[e._v("foo()")]),e._v(" always calls the second version of "),t("code",[e._v("f()")]),e._v(".")]),e._v(" "),t("p",[e._v("Why is overloading useful? It allows you to express “variations on a theme” more clearly than if you were forced to use different function names. Suppose you want addition functions:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Overloading/OverloadingAdd.kt\npackage overloading\nimport atomictest.eq\n\nfun addInt(i: Int, j: Int) = i + j\nfun addDouble(i: Double, j: Double) = i + j\n\nfun add(i: Int, j: Int) = i + j\nfun add(i: Double, j: Double) = i + j\n\nfun main() {\n  addInt(5, 6) eq add(5, 6)\n  addDouble(56.23, 44.77) eq\n    add(56.23, 44.77)\n}\n")])])]),t("p",[t("code",[e._v("addInt()")]),e._v(" takes two "),t("code",[e._v("Int")]),e._v("s and returns an "),t("code",[e._v("Int")]),e._v(", while "),t("code",[e._v("addDouble()")]),e._v(" takes two "),t("code",[e._v("Double")]),e._v("s and returns a "),t("code",[e._v("Double")]),e._v(". Without overloading, you can’t just name the operation "),t("code",[e._v("add()")]),e._v(", so programmers typically conflate "),t("em",[e._v("what")]),e._v(" with "),t("em",[e._v("how")]),e._v(" to produce unique names (you can also create unique names using random characters but the typical pattern is to use meaningful information like parameter types). In contrast, the overloaded "),t("code",[e._v("add()")]),e._v(" is much clearer.")]),e._v(" "),t("ul",[t("li",[e._v("-")])]),e._v(" "),t("p",[e._v("The lack of overloading in a language is not a terrible hardship, but the feature provides valuable simplification, producing more readable code. With overloading, you just say "),t("em",[e._v("what")]),e._v(", which raises the level of abstraction and puts less mental load on the reader. If you want to know "),t("em",[e._v("how")]),e._v(", look at the parameters. Notice also that overloading reduces redundancy: If we must say "),t("code",[e._v("addInt()")]),e._v(" and "),t("code",[e._v("addDouble()")]),e._v(", then we essentially repeat the parameter information in the function name.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);