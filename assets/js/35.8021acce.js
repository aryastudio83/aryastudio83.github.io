(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{407:function(e,n,t){"use strict";t.r(n);var a=t(44),o=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[e._v("#")]),e._v(" Functions")]),e._v(" "),t("blockquote",[t("p",[e._v("A "),t("em",[e._v("function")]),e._v(" is like a small program that has its own name, and can be executed ("),t("em",[e._v("invoked")]),e._v(") by calling that name from another function.")])]),e._v(" "),t("p",[e._v("A function combines a group of activities, and is the most basic way to organize your programs and to re-use code.")]),e._v(" "),t("p",[e._v("You pass information into a function, and the function uses that information to calculate and produce a result. The basic form of a function is:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fun functionName(p1: Type1, p2: Type2, ...): ReturnType {\n  lines of code\n  return result\n}\n")])])]),t("p",[t("code",[e._v("p1")]),e._v(" and "),t("code",[e._v("p2")]),e._v(" are the "),t("em",[e._v("parameters")]),e._v(": the information you pass into the function. Each parameter has an identifier name ("),t("code",[e._v("p1")]),e._v(", "),t("code",[e._v("p2")]),e._v(") followed by a colon and the type of that parameter. The closing parenthesis of the parameter list is followed by a colon and the type of result produced by the function. The lines of code in the "),t("em",[e._v("function body")]),e._v(" are enclosed in curly braces. The expression following the "),t("code",[e._v("return")]),e._v(" keyword is the result the function produces when it’s finished.")]),e._v(" "),t("p",[e._v("A parameter is how you define what is passed into a function—it’s the placeholder. An argument is the actual value that you pass into the function.")]),e._v(" "),t("p",[e._v("The combination of name, parameters and return type is called the "),t("em",[e._v("function signature")]),e._v(".")]),e._v(" "),t("p",[e._v("Here’s a simple function called "),t("code",[e._v("multiplyByTwo()")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Functions/MultiplyByTwo.kt\n\nfun multiplyByTwo(x: Int): Int {  // [1]\n  println("Inside multiplyByTwo") // [2]\n  return x * 2\n}\n\nfun main() {\n  val r = multiplyByTwo(5)        // [3]\n  println(r)\n}\n/* Output:\nInside multiplyByTwo\n10\n*/\n')])])]),t("ul",[t("li",[t("strong",[e._v("[1]")]),e._v(" Notice the "),t("code",[e._v("fun")]),e._v(" keyword, the function name, and the parameter list consisting of a single parameter. This function takes an "),t("code",[e._v("Int")]),e._v(" parameter and returns an "),t("code",[e._v("Int")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("[2]")]),e._v(" These two lines are the body of the function. The final line returns the value of its calculation "),t("code",[e._v("x * 2")]),e._v("  as the result of the function.")]),e._v(" "),t("li",[t("strong",[e._v("[3]")]),e._v(" This line "),t("em",[e._v("calls")]),e._v(" the function with an appropriate argument, and captures the result into "),t("code",[e._v("val r")]),e._v(". A function call mimics the form of its declaration: the function name, followed by arguments inside parentheses.")])]),e._v(" "),t("p",[e._v("The function code is executed by calling the function, using the function name "),t("code",[e._v("multiplyByTwo()")]),e._v(" as an abbreviation for that code. This is why functions are the most basic form of simplification and code reuse in programming. You can also think of a function as an expression with substitutable values (the parameters).")]),e._v(" "),t("p",[t("code",[e._v("println()")]),e._v(" is also a function call—it just happens to be provided by Kotlin. We refer to functions defined by Kotlin as "),t("em",[e._v("library functions")]),e._v(".")]),e._v(" "),t("p",[e._v("If the function doesn’t provide a meaningful result, its return type is "),t("code",[e._v("Unit")]),e._v(". You can specify "),t("code",[e._v("Unit")]),e._v(" explicitly if you want, but Kotlin lets you omit it:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Functions/SayHello.kt\n\nfun sayHello() {\n  println("Hallo!")\n}\n\nfun sayGoodbye(): Unit {\n  println("Auf Wiedersehen!")\n}\n\nfun main() {\n  sayHello()\n  sayGoodbye()\n}\n/* Output:\nHallo!\nAuf Wiedersehen!\n*/\n')])])]),t("p",[e._v("Both "),t("code",[e._v("sayHello()")]),e._v(" and "),t("code",[e._v("sayGoodbye()")]),e._v(" return "),t("code",[e._v("Unit")]),e._v(", but "),t("code",[e._v("sayHello()")]),e._v(" leaves out the explicit declaration. The "),t("code",[e._v("main()")]),e._v(" function also returns "),t("code",[e._v("Unit")]),e._v(".")]),e._v(" "),t("p",[e._v("If a function is only a single expression, you can use the abbreviated syntax of an equals sign followed by the expression:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fun functionName(arg1: Type1, arg2: Type2, ...): ReturnType = expression\n")])])]),t("p",[e._v("A function body surrounded by curly braces is called a "),t("em",[e._v("block body")]),e._v(". A function body using the equals syntax is called an "),t("em",[e._v("expression body")]),e._v(".")]),e._v(" "),t("p",[e._v("Here, "),t("code",[e._v("multiplyByThree()")]),e._v(" uses an expression body:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Functions/MultiplyByThree.kt\n\nfun multiplyByThree(x: Int): Int = x * 3\n\nfun main() {\n  println(multiplyByThree(5))\n}\n/* Output:\n15\n*/\n")])])]),t("p",[e._v("This is a short version of saying "),t("code",[e._v("return x * 3")]),e._v(" inside a block body.")]),e._v(" "),t("p",[e._v("Kotlin infers the return type of a function that has an expression body:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Functions/MultiplyByFour.kt\n\nfun multiplyByFour(x: Int) = x * 4\n\nfun main() {\n  val result: Int = multiplyByFour(5)\n  println(result)\n}\n/* Output:\n20\n*/\n")])])]),t("p",[e._v("Kotlin infers that "),t("code",[e._v("multiplyByFour()")]),e._v(" returns an "),t("code",[e._v("Int")]),e._v(".")]),e._v(" "),t("p",[e._v("Kotlin can "),t("em",[e._v("only")]),e._v(" infer return types for expression bodies. If a function has a block body and you omit its type, that function returns "),t("code",[e._v("Unit")]),e._v(".")]),e._v(" "),t("ul",[t("li",[e._v("-")])]),e._v(" "),t("p",[e._v("When writing functions, choose descriptive names. This makes the code easier to read, and can often reduce the need for code comments. We can’t always be as descriptive as we would prefer with the function names in this book because we’re constrained by line widths.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);