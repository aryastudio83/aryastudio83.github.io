(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{440:function(e,a,n){"use strict";n.r(a);var t=n(44),l=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"nullable-types"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nullable-types"}},[e._v("#")]),e._v(" Nullable Types")]),e._v(" "),n("blockquote",[n("p",[e._v("Consider a function that sometimes produces “no result.” When this happens, the function doesn’t produce an error per se. Nothing went wrong, there’s just “no answer.”")])]),e._v(" "),n("p",[e._v("A good example is retrieving a value from a "),n("code",[e._v("Map")]),e._v(". If the "),n("code",[e._v("Map")]),e._v(" doesn’t contain a value for a given key, it can’t give you an answer and returns a "),n("code",[e._v("null")]),e._v(" reference to indicate “no value”:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NullableTypes/NullInMaps.kt\nimport atomictest.eq\n\nfun main() {\n  val map = mapOf(0 to "yes", 1 to "no")\n  map[2] eq null\n}\n')])])]),n("p",[e._v("Languages like Java allow a result to be either "),n("code",[e._v("null")]),e._v(" or a meaningful value. Unfortunately, if you treat "),n("code",[e._v("null")]),e._v(" the same way you treat a meaningful value, you get a dramatic failure (In Java, this produces a "),n("code",[e._v("NullPointerException")]),e._v("; in a more primitive language like C, a "),n("code",[e._v("null")]),e._v(" pointer can crash the process or even the operating system or machine). The creator of the "),n("code",[e._v("null")]),e._v(" reference, "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Tony_Hoare",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tony Hoare"),n("OutboundLink")],1),e._v(", refers to it as “my billion-dollar mistake” (although it has arguably cost much more than that).")]),e._v(" "),n("p",[e._v("One possible solution to this problem is for a language to never allow "),n("code",[e._v("null")]),e._v("s in the first place, and instead introduce a special “no value” indicator. Kotlin might have done this, except that it must interact with Java, and Java uses "),n("code",[e._v("null")]),e._v("s.")]),e._v(" "),n("p",[e._v("Kotlin’s solution is arguably the best compromise: types default to non-nullable. However, if something can produce a "),n("code",[e._v("null")]),e._v(" result, you must append a question mark to the type name to explicitly tag that result as nullable:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NullableTypes/NullableTypes.kt\nimport atomictest.eq\n\nfun main() {\n  val s1 = "abc"             // [1]\n\n  // Compile-time error:\n  // val s2: String = null   // [2]\n\n  // Nullable definitions:\n  val s3: String? = null     // [3]\n  val s4: String? = s1       // [4]\n\n  // Compile-time error:\n  // val s5: String = s4     // [5]\n  val s6 = s4                // [6]\n\n  s1 eq "abc"\n  s3 eq null\n  s4 eq "abc"\n  s6 eq "abc"\n}\n')])])]),n("ul",[n("li",[n("strong",[e._v("[1]")]),e._v(" "),n("code",[e._v("s1")]),e._v(" can’t contain a "),n("code",[e._v("null")]),e._v(" reference. All the "),n("code",[e._v("var")]),e._v("s and "),n("code",[e._v("val")]),e._v("s we’ve created in the book so far are automatically non-nullable.")]),e._v(" "),n("li",[n("strong",[e._v("[2]")]),e._v(" The error message is: "),n("em",[e._v("null can not be a value of a non-null type String")]),e._v(".")]),e._v(" "),n("li",[n("strong",[e._v("[3]")]),e._v(" To define an identifier that can contain a "),n("code",[e._v("null")]),e._v(" reference, you put a "),n("code",[e._v("?")]),e._v(" at the end of the type name. Such an identifier can contain either "),n("code",[e._v("null")]),e._v(" or a regular value.")]),e._v(" "),n("li",[n("strong",[e._v("[4]")]),e._v(" Both "),n("code",[e._v("null")]),e._v("s and regular non-nullable values can be stored in a nullable type.")]),e._v(" "),n("li",[n("strong",[e._v("[5]")]),e._v(" You can’t assign an identifier of a nullable type to an identifier of a non-null type. Kotlin emits: "),n("em",[e._v("Type mismatch: inferred type is String? but String was expected.")]),e._v(" Even if the actual value is non-null as in this case (we know it’s "),n("code",[e._v('"abc"')]),e._v("), Kotlin won’t allow it because they are two different types.")]),e._v(" "),n("li",[n("strong",[e._v("[6]")]),e._v(" If you use type inference, Kotlin produces the appropriate type. Here, "),n("code",[e._v("s6")]),e._v(" is nullable because "),n("code",[e._v("s4")]),e._v(" is nullable.")])]),e._v(" "),n("p",[e._v("Even though it looks like we just modify an existing type by adding a "),n("code",[e._v("?")]),e._v(" at the end, we’re actually specifying a "),n("em",[e._v("different type")]),e._v(". For example, "),n("code",[e._v("String")]),e._v(" and "),n("code",[e._v("String?")]),e._v(" are two different types. The "),n("code",[e._v("String?")]),e._v(" type forbids the operations in lines "),n("strong",[e._v("[2]")]),e._v(" and "),n("strong",[e._v("[5]")]),e._v(", thus guaranteeing that a value of a non-nullable type is never "),n("code",[e._v("null")]),e._v(".")]),e._v(" "),n("p",[e._v("Retrieving a value from a "),n("code",[e._v("Map")]),e._v(" using square brackets produces a nullable result, because the underlying "),n("code",[e._v("Map")]),e._v(" implementation comes from Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NullableTypes/NullableInMap.kt\nimport atomictest.eq\n\nfun main() {\n  val map = mapOf(0 to "yes", 1 to "no")\n  val first: String? = map[0]\n  val second: String? = map[2]\n  first eq "yes"\n  second eq null\n}\n')])])]),n("p",[e._v("Why is it important to know that a value can’t be "),n("code",[e._v("null")]),e._v("? Many operations implicitly assume a non-nullable result. For example, calling a member function will fail with an exception if the receiver value is "),n("code",[e._v("null")]),e._v(". In Java such a call will fail with a "),n("code",[e._v("NullPointerException")]),e._v(" (often abbreviated "),n("em",[e._v("NPE")]),e._v("). Because almost any value can be "),n("code",[e._v("null")]),e._v(" in Java, any function invocation can fail this way. In these cases you must write code to check for "),n("code",[e._v("null")]),e._v(" results, or rely on other parts of the code to guard against "),n("code",[e._v("null")]),e._v("s.")]),e._v(" "),n("p",[e._v("In Kotlin you can’t simply "),n("em",[e._v("dereference")]),e._v(" (call a member function or access a member property) a value of a nullable type:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NullableTypes/Dereference.kt\nimport atomictest.eq\n\nfun main() {\n  val s1: String = "abc"\n  val s2: String? = s1\n\n  s1.length eq 3         // [1]\n  // Doesn\'t compile:\n  // s2.length           // [2]\n}\n')])])]),n("p",[e._v("You can access members of a non-nullable type as in "),n("strong",[e._v("[1]")]),e._v(". If you reference members of a nullable type, as in "),n("strong",[e._v("[2]")]),e._v(", Kotlin emits an error.")]),e._v(" "),n("p",[e._v("Values of most types are stored as references to the objects in memory. That’s the meaning of the term "),n("em",[e._v("dereference")]),e._v("—to access an object, you retrieve its value from memory.")]),e._v(" "),n("p",[e._v("The most straightforward way to ensure that dereferencing a nullable type won’t throw a "),n("code",[e._v("NullPointerException")]),e._v(" is to explicitly check that the reference is not "),n("code",[e._v("null")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NullableTypes/ExplicitCheck.kt\nimport atomictest.eq\n\nfun main() {\n  val s: String? = "abc"\n  if (s != null)\n    s.length eq 3\n}\n')])])]),n("p",[e._v("After the explicit "),n("code",[e._v("if")]),e._v("-check, Kotlin allows you to dereference a nullable. But writing this "),n("code",[e._v("if")]),e._v(" whenever you work with nullable types is too noisy for such a common operation. Kotlin has concise syntax to alleviate this problem, which you’ll learn about in subsequent atoms.")]),e._v(" "),n("p",[e._v("Whenever you create a new class, Kotlin automatically includes nullable and non-nullable types:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NullableTypes/Amphibian.kt\npackage nullabletypes\n\nclass Amphibian\n\nenum class Species {\n  Frog, Toad, Salamander, Caecilian\n}\n\nfun main() {\n  val a1: Amphibian = Amphibian()\n  val a2: Amphibian? = null\n  val at1: Species = Species.Toad\n  val at2: Species? = null\n}\n")])])]),n("p",[e._v("As you can see, we didn’t do anything special to produce the complementary nullable types—they’re available by default.")]),e._v(" "),n("p",[n("em",[n("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);a.default=l.exports}}]);