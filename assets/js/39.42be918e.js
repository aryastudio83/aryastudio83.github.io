(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{410:function(e,n,s){"use strict";s.r(n);var o=s(44),t=Object(o.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"booleans"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#booleans"}},[e._v("#")]),e._v(" Booleans")]),e._v(" "),s("blockquote",[s("p",[e._v("["),s("code",[e._v("if")]),e._v(" Expressions](javascript:void(0)) demonstrated the “not” operator "),s("code",[e._v("!")]),e._v(", which negates a "),s("code",[e._v("Boolean")]),e._v(" value. This atom introduces more "),s("em",[e._v("Boolean Algebra")]),e._v(".")])]),e._v(" "),s("p",[e._v("We start with the operators “and” and “or”:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("&&")]),e._v(" (and): Produces "),s("code",[e._v("true")]),e._v(" only if the "),s("code",[e._v("Boolean")]),e._v(" expression on the left of the operator and the one on the right are both "),s("code",[e._v("true")]),e._v(".")]),e._v(" "),s("li",[s("code",[e._v("||")]),e._v(" (or): Produces "),s("code",[e._v("true")]),e._v(" if either the expression on the left or right of the operator is "),s("code",[e._v("true")]),e._v(", or if both are "),s("code",[e._v("true")]),e._v(".")])]),e._v(" "),s("p",[e._v("In this example, we determine whether a business is open or closed, based on the "),s("code",[e._v("hour")]),e._v(":")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('// Booleans/Open1.kt\n\nfun isOpen1(hour: Int) {\n  val open = 9\n  val closed = 20\n  println("Operating hours: $open - $closed")\n  val status =\n    if (hour >= open && hour <= closed) // [1]\n      true\n    else\n      false\n  println("Open: $status")\n}\n\nfun main() = isOpen1(6)\n/* Output:\nOperating hours: 9 - 20\nOpen: false\n*/\n')])])]),s("p",[s("code",[e._v("main()")]),e._v(" is a single function call, so we can use an expression body as described in [Functions](javascript:void(0)).")]),e._v(" "),s("p",[e._v("The "),s("code",[e._v("if")]),e._v(" expression in "),s("strong",[e._v("[1]")]),e._v(" Checks whether "),s("code",[e._v("hour")]),e._v(" is between the opening time and closing time, so we combine the expressions with the "),s("code",[e._v("Boolean")]),e._v(" "),s("code",[e._v("&&")]),e._v(" (and).")]),e._v(" "),s("p",[e._v("The "),s("code",[e._v("if")]),e._v(" expression can be simplified. The result of the expression "),s("code",[e._v("if(cond) true else false")]),e._v(" is just "),s("code",[e._v("cond")]),e._v(":")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('// Booleans/Open2.kt\n\nfun isOpen2(hour: Int) {\n  val open = 9\n  val closed = 20\n  println("Operating hours: $open - $closed")\n  val status = hour >= open && hour <= closed\n  println("Open: $status")\n}\n\nfun main() = isOpen2(6)\n/* Output:\nOperating hours: 9 - 20\nOpen: false\n*/\n')])])]),s("p",[e._v("Let’s reverse the logic and check whether the business is currently closed. The “or” operator "),s("code",[e._v("||")]),e._v(" produces "),s("code",[e._v("true")]),e._v(" if at least one of the conditions is satisfied:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('// Booleans/Closed.kt\n\nfun isClosed(hour: Int) {\n  val open = 9\n  val closed = 20\n  println("Operating hours: $open - $closed")\n  val status = hour < open || hour > closed\n  println("Closed: $status")\n}\n\nfun main() = isClosed(6)\n/* Output:\nOperating hours: 9 - 20\nClosed: true\n*/\n')])])]),s("p",[s("code",[e._v("Boolean")]),e._v(" operators enable complicated logic in compact expressions. However, things can easily become confusing. Strive for readability and specify your intentions explicitly.")]),e._v(" "),s("p",[e._v("Here’s an example of a complicated "),s("code",[e._v("Boolean")]),e._v(" expression where different evaluation order produces different results:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// Booleans/EvaluationOrder.kt\n\nfun main() {\n  val sunny = true\n  val hoursSleep = 6\n  val exercise = false\n  val temp = 55\n\n  // [1]:\n  val happy1 = sunny && temp > 50 ||\n    exercise && hoursSleep > 7\n  println(happy1)\n\n  // [2]:\n  val sameHappy1 = (sunny && temp > 50) ||\n    (exercise && hoursSleep > 7)\n  println(sameHappy1)\n\n  // [3]:\n  val notSame =\n    (sunny && temp > 50 || exercise) &&\n      hoursSleep > 7\n  println(notSame)\n}\n/* Output:\ntrue\ntrue\nfalse\n*/\n")])])]),s("p",[e._v("The "),s("code",[e._v("Boolean")]),e._v(" expressions are "),s("code",[e._v("sunny")]),e._v(", "),s("code",[e._v("temp > 50")]),e._v(", "),s("code",[e._v("exercise")]),e._v(", and "),s("code",[e._v("hoursSleep > 7")]),e._v(". We read "),s("code",[e._v("happy1")]),e._v(" as “It’s sunny "),s("em",[e._v("and")]),e._v(" the temperature is greater than 50 "),s("em",[e._v("or")]),e._v(" I’ve exercised "),s("em",[e._v("and")]),e._v(" had more than 7 hours of sleep.” But does "),s("code",[e._v("&&")]),e._v(" have precedence over "),s("code",[e._v("||")]),e._v(", or the opposite?")]),e._v(" "),s("p",[e._v("The expression in "),s("strong",[e._v("[1]")]),e._v(" uses Kotlin’s default evaluation order. This produces the same result as the expression in "),s("strong",[e._v("[2]")]),e._v(" because, without parentheses, the “ands” are evaluated first, then the “or”. The expression in "),s("strong",[e._v("[3]")]),e._v(" uses parentheses to produce a different result. In "),s("strong",[e._v("[3]")]),e._v(", we’re only happy if we get at least 7 hours of sleep.")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);