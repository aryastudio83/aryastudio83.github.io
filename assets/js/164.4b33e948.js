(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{544:function(e,t,n){"use strict";n.r(t);var i=n(44),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"operations-on-collections"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#operations-on-collections"}},[e._v("#")]),e._v(" Operations on Collections")]),e._v(" "),n("blockquote",[n("p",[e._v("An essential aspect of functional languages is the ability to easily perform batch operations on collections of objects.")])]),e._v(" "),n("p",[e._v("Most functional languages provide powerful support for working with collections, and Kotlin is no exception. You’ve already seen "),n("code",[e._v("map()")]),e._v(", "),n("code",[e._v("filter()")]),e._v(", "),n("code",[e._v("any()")]),e._v(" and "),n("code",[e._v("forEach()")]),e._v(". This atom shows additional operations available for "),n("code",[e._v("List")]),e._v("s and other collections.")]),e._v(" "),n("p",[e._v("We start by looking at various ways to manufacture "),n("code",[e._v("List")]),e._v("s. Here, we initialize "),n("code",[e._v("List")]),e._v("s using lambdas:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// OperationsOnCollections/CreatingLists.kt\nimport atomictest.eq\n\nfun main() {\n  // The lambda argument is the element index:\n  val list1 = List(10) { it }\n  list1 eq "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"\n\n  // A list of a single value:\n  val list2 = List(10) { 0 }\n  list2 eq "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"\n\n  // A list of letters:\n  val list3 = List(10) { \'a\' + it }\n  list3 eq "[a, b, c, d, e, f, g, h, i, j]"\n\n  // Cycle through a sequence:\n  val list4 = List(10) { list3[it % 3] }\n  list4 eq "[a, b, c, a, b, c, a, b, c, a]"\n}\n')])])]),n("p",[e._v("This version of the "),n("code",[e._v("List")]),e._v(" constructor has two parameters: the size of the "),n("code",[e._v("List")]),e._v(" and a lambda that initializes each "),n("code",[e._v("List")]),e._v(" element (the element index is passed in as the "),n("code",[e._v("it")]),e._v(" argument). Remember that if a lambda is the last argument, it can be separated from the argument list.")]),e._v(" "),n("p",[n("code",[e._v("MutableList")]),e._v("s can be initialized in the same way. Here we see the initialization lambda both inside the argument list ("),n("code",[e._v("mutableList1")]),e._v(") and separated from the argument list ("),n("code",[e._v("mutableList2")]),e._v("):")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// OperationsOnCollections/ListInit.kt\nimport atomictest.eq\n\nfun main() {\n  val mutableList1 =\n    MutableList(5, { 10 * (it + 1) })\n  mutableList1 eq "[10, 20, 30, 40, 50]"\n  val mutableList2 =\n    MutableList(5) { 10 * (it + 1) }\n  mutableList2 eq "[10, 20, 30, 40, 50]"\n}\n')])])]),n("p",[e._v("Note that "),n("code",[e._v("List()")]),e._v(" and "),n("code",[e._v("MutableList()")]),e._v(" are not constructors, but functions. Their names intentionally begin with an upper-case letter to make them look like constructors.")]),e._v(" "),n("p",[e._v("Many collection functions take a predicate and test it against the elements of a collection, some of which we’ve already seen:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("filter()")]),e._v(" produces a list containing all elements matching the given predicate.")]),e._v(" "),n("li",[n("code",[e._v("any()")]),e._v(" returns "),n("code",[e._v("true")]),e._v(" if at least one element matches the predicate.")]),e._v(" "),n("li",[n("code",[e._v("all()")]),e._v(" checks whether all elements match the predicate.")]),e._v(" "),n("li",[n("code",[e._v("none()")]),e._v(" checks that no elements match the predicate.")]),e._v(" "),n("li",[n("code",[e._v("find()")]),e._v(" and "),n("code",[e._v("firstOrNull()")]),e._v(" both return the first element matching the predicate, or "),n("code",[e._v("null")]),e._v(" if no such element was found.")]),e._v(" "),n("li",[n("code",[e._v("lastOrNull()")]),e._v(" returns the last element matching the predicate, or "),n("code",[e._v("null")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("count()")]),e._v(" returns the number of elements matching the predicate.")])]),e._v(" "),n("p",[e._v("Here are simple examples for each function:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// OperationsOnCollections/Predicates.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(-3, -1, 5, 7, 10)\n\n  list.filter { it > 0 } eq listOf(5, 7, 10)\n  list.count { it > 0 } eq 3\n\n  list.find { it > 0 } eq 5\n  list.firstOrNull { it > 0 } eq 5\n  list.lastOrNull { it < 0 } eq -1\n\n  list.any { it > 0 } eq true\n  list.any { it != 0 } eq true\n\n  list.all { it > 0 } eq false\n  list.all { it != 0 } eq true\n\n  list.none { it > 0 } eq false\n  list.none { it == 0 } eq true\n}\n")])])]),n("p",[n("code",[e._v("filter()")]),e._v(" and "),n("code",[e._v("count()")]),e._v(" apply the predicate against each element, while "),n("code",[e._v("any()")]),e._v(" or "),n("code",[e._v("find()")]),e._v(" stop when the first matching result is found. For example, if the first element satisfies the predicate, "),n("code",[e._v("any()")]),e._v(" returns "),n("code",[e._v("true")]),e._v(" right away, while "),n("code",[e._v("find()")]),e._v(" returns the first matching element. The only time all the elements are processed is if the list contains no elements matching the given predicate.")]),e._v(" "),n("p",[n("code",[e._v("filter()")]),e._v(" returns a group of elements satisfying the given predicate. Sometimes you may be interested in the remaining group—the elements that don’t satisfy the predicate. "),n("code",[e._v("filterNot()")]),e._v(" produces this remaining group, but "),n("code",[e._v("partition()")]),e._v(" can be more useful because it simultaneously produces both lists:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// OperationsOnCollections/Partition.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(-3, -1, 5, 7, 10)\n  val isPositive = { i: Int -> i > 0 }\n\n  list.filter(isPositive) eq "[5, 7, 10]"\n  list.filterNot(isPositive) eq "[-3, -1]"\n\n  val (pos, neg) = list.partition { it > 0 }\n  pos eq "[5, 7, 10]"\n  neg eq "[-3, -1]"\n}\n')])])]),n("p",[n("code",[e._v("partition()")]),e._v(" produces a "),n("code",[e._v("Pair")]),e._v(" object containing "),n("code",[e._v("List")]),e._v("s. Using [Destructuring Declarations](javascript:void(0)), you can assign the elements of the "),n("code",[e._v("Pair")]),e._v(" to a parenthesized group of "),n("code",[e._v("var")]),e._v("s or "),n("code",[e._v("val")]),e._v("s. "),n("em",[e._v("Destructuring")]),e._v(" means defining multiple "),n("code",[e._v("var")]),e._v("s or "),n("code",[e._v("val")]),e._v("s and initializing them simultaneously, from the expression on the right side of the assignment. Here, destructuring is used with a custom function:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// OperationsOnCollections/PairOfLists.kt\npackage operationsoncollections\nimport atomictest.eq\n\nfun createPair() = Pair(1, "one")\n\nfun main() {\n  val (i, s) = createPair()\n  i eq 1\n  s eq "one"\n}\n')])])]),n("p",[n("code",[e._v("filterNotNull()")]),e._v(" produces a new "),n("code",[e._v("List")]),e._v(" with the "),n("code",[e._v("null")]),e._v("s removed:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// OperationsOnCollections/FilterNotNull.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 2, null)\n  list.filterNotNull() eq "[1, 2]"\n}\n')])])]),n("p",[e._v("In [Lists](javascript:void(0)), we saw functions such as "),n("code",[e._v("sum()")]),e._v(" or "),n("code",[e._v("sorted()")]),e._v(" applied to a list of comparable elements. These functions can’t be called on lists of non-summable or non-comparable elements, but they have counterparts named "),n("code",[e._v("sumBy()")]),e._v(" and "),n("code",[e._v("sortedBy()")]),e._v(". You pass a function (often a lambda) as an argument, which specifies the attribute to use for the operation:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// OperationsOnCollections/ByOperations.kt\npackage operationsoncollections\nimport atomictest.eq\n\ndata class Product(\n  val description: String,\n  val price: Double\n)\n\nfun main() {\n  val products = listOf(\n    Product("bread", 2.0),\n    Product("wine", 5.0)\n  )\n  products.sumByDouble { it.price } eq 7.0\n\n  products.sortedByDescending { it.price } eq\n    "[Product(description=wine, price=5.0)," +\n    " Product(description=bread, price=2.0)]"\n  products.minByOrNull { it.price } eq\n    Product("bread", 2.0)\n}\n')])])]),n("p",[e._v("Note that we have two functions "),n("code",[e._v("sumBy()")]),e._v(" and "),n("code",[e._v("sumByDouble()")]),e._v(" to sum integer and double values, respectively. "),n("code",[e._v("sorted()")]),e._v(" and "),n("code",[e._v("sortedBy()")]),e._v(" sort the collection in ascending order, while "),n("code",[e._v("sortedDescending()")]),e._v(" and "),n("code",[e._v("sortedByDescending()")]),e._v(" sort the collection in descending order.")]),e._v(" "),n("p",[n("code",[e._v("minByOrNull")]),e._v(" returns a minimum value based on a given criteria or "),n("code",[e._v("null")]),e._v(" if the list is empty.")]),e._v(" "),n("p",[n("code",[e._v("take()")]),e._v(" and "),n("code",[e._v("drop()")]),e._v(" produce or remove (respectively) the first element, while "),n("code",[e._v("takeLast()")]),e._v(" and "),n("code",[e._v("dropLast()")]),e._v(" produce or remove the last element. These have counterparts that accept a predicate specifying the elements to take or drop:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// OperationsOnCollections/TakeOrDrop.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf('a', 'b', 'c', 'X', 'Z')\n  list.takeLast(3) eq \"[c, X, Z]\"\n  list.takeLastWhile { it.isUpperCase() } eq\n    \"[X, Z]\"\n  list.drop(1) eq \"[b, c, X, Z]\"\n  list.dropWhile { it.isLowerCase() } eq\n    \"[X, Z]\"\n}\n")])])]),n("p",[e._v("Operations like those you’ve seen for "),n("code",[e._v("List")]),e._v("s are also available for "),n("code",[e._v("Set")]),e._v("s:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// OperationsOnCollections/SetOperations.kt\nimport atomictest.eq\n\nfun main() {\n  val set = setOf("a", "ab", "ac")\n  set.maxByOrNull { it.length }?.length eq 2\n  set.filter {\n    it.contains(\'b\')\n  } eq listOf("ab")\n  set.map { it.length } eq listOf(1, 2, 2)\n}\n')])])]),n("p",[n("code",[e._v("maxByOrNull()")]),e._v(" returns "),n("code",[e._v("null")]),e._v(" if a collection is empty, so its result is nullable.")]),e._v(" "),n("p",[e._v("Note that "),n("code",[e._v("filter()")]),e._v(" and "),n("code",[e._v("map()")]),e._v(", when applied to a "),n("code",[e._v("Set")]),e._v(", return their results in a "),n("code",[e._v("List")]),e._v(".")]),e._v(" "),n("p",[n("em",[n("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);