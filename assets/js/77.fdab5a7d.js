(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{447:function(e,n,t){"use strict";t.r(n);var a=t(44),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"member-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#member-references"}},[e._v("#")]),e._v(" Member References")]),e._v(" "),t("blockquote",[t("p",[e._v("You can pass a member reference as a function argument.")])]),e._v(" "),t("p",[t("em",[e._v("Member references")]),e._v("—for functions, properties and constructors—can replace trivial lambdas that simply call the corresponding function, property or constructor.")]),e._v(" "),t("p",[e._v("A member reference uses a double colon to separate the class name from the function or property. Here, "),t("code",[e._v("Message::isRead")]),e._v(" is a member reference:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// MemberReferences/PropertyReference.kt\npackage memberreferences1\nimport atomictest.eq\n\ndata class Message(\n  val sender: String,\n  val text: String,\n  val isRead: Boolean\n)\n\nfun main() {\n  val messages = listOf(\n    Message("Kitty", "Hey!", true),\n    Message("Kitty", "Where are you?", false))\n  val unread =\n    messages.filterNot(Message::isRead)\n  unread.size eq 1\n  unread.single().text eq "Where are you?"\n}\n')])])]),t("p",[e._v("To filter for unread messages, we use the library function "),t("code",[e._v("filterNot()")]),e._v(", which takes a predicate. In our case, the predicate indicates whether a message is already read. We could pass a lambda, but instead we pass the property reference "),t("code",[e._v("Message::isRead")]),e._v(".")]),e._v(" "),t("p",[e._v("Property references are useful when specifying a non-trivial sort order:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// MemberReferences/SortWith.kt\nimport memberreferences1.Message\nimport atomictest.eq\n\nfun main() {\n  val messages = listOf(\n    Message("Kitty", "Hey!", true),\n    Message("Kitty", "Where are you?", false),\n    Message("Boss", "Meeting today", false))\n  messages.sortedWith(compareBy(\n    Message::isRead, Message::sender)) eq\n    listOf(\n      // First unread, sorted by sender:\n      Message("Boss", "Meeting today", false),\n      Message("Kitty",\n        "Where are you?", false),\n      // Then read, also sorted by sender:\n      Message("Kitty", "Hey!", true))\n}\n')])])]),t("p",[e._v("The library function "),t("code",[e._v("sortedWith()")]),e._v(" sorts a list using a "),t("em",[e._v("comparator")]),e._v(", which is an object used to compare two elements. The library function "),t("code",[e._v("compareBy()")]),e._v(" builds a comparator based on its parameters, which are a list of predicates. Using "),t("code",[e._v("compareBy()")]),e._v(" with a single argument is equivalent to calling "),t("code",[e._v("sortedBy()")]),e._v(".")]),e._v(" "),t("h3",{attrs:{id:"function-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#function-references"}},[e._v("#")]),e._v(" Function References")]),e._v(" "),t("p",[e._v("Suppose you want to check whether a "),t("code",[e._v("List")]),e._v(" contains any important messages, not just unread messages. You might have a number of complicated criteria to decide what “important” means. You can put this logic into a lambda, but that lambda could easily become large and complex. The code is more understandable if you extract it into a separate function. In Kotlin you can’t pass a function where a function type is expected, but you can pass a "),t("em",[e._v("reference")]),e._v(" to that function:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// MemberReferences/FunctionReference.kt\npackage memberreferences2\nimport atomictest.eq\n\ndata class Message(\n  val sender: String,\n  val text: String,\n  val isRead: Boolean,\n  val attachments: List<Attachment>\n)\n\ndata class Attachment(\n  val type: String,\n  val name: String\n)\n\nfun Message.isImportant(): Boolean =\n  text.contains("Salary increase") ||\n    attachments.any {\n      it.type == "image" &&\n        it.name.contains("cat")\n    }\n\nfun main() {\n  val messages = listOf(Message(\n    "Boss", "Let\'s discuss goals " +\n    "for next year", false,\n    listOf(Attachment("image", "cute cats"))))\n  messages.any(Message::isImportant) eq true\n}\n')])])]),t("p",[e._v("This new "),t("code",[e._v("Message")]),e._v(" class adds an "),t("code",[e._v("attachments")]),e._v(" property, and the extension function "),t("code",[e._v("Message.isImportant()")]),e._v(" uses this information. In the call to "),t("code",[e._v("messages.any()")]),e._v(", we create a reference to an extension function—references are not limited to member functions.")]),e._v(" "),t("p",[e._v("If you have a top-level function taking "),t("code",[e._v("Message")]),e._v(" as its only parameter, you can pass it as a reference. When you create a reference to a top-level function, there’s no class name, so it’s written "),t("code",[e._v("::function")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// MemberReferences/TopLevelFunctionRef.kt\npackage memberreferences2\nimport atomictest.eq\n\nfun ignore(message: Message) =\n  !message.isImportant() &&\n    message.sender in setOf("Boss", "Mom")\n\nfun main() {\n  val text = "Let\'s discuss goals " +\n    "for the next year"\n  val msgs = listOf(\n    Message("Boss", text, false, listOf()),\n    Message("Boss", text, false, listOf(\n      Attachment("image", "cute cats"))))\n  msgs.filter(::ignore).size eq 1\n  msgs.filterNot(::ignore).size eq 1\n}\n')])])]),t("h3",{attrs:{id:"constructor-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor-references"}},[e._v("#")]),e._v(" Constructor References")]),e._v(" "),t("p",[e._v("You can create a reference to a constructor using the class name.")]),e._v(" "),t("p",[e._v("Here, "),t("code",[e._v("names.mapIndexed()")]),e._v(" takes the constructor reference "),t("code",[e._v("::Student")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// MemberReferences/ConstructorReference.kt\npackage memberreferences3\nimport atomictest.eq\n\ndata class Student(\n  val id: Int,\n  val name: String\n)\n\nfun main() {\n  val names = listOf("Alice", "Bob")\n  val students =\n    names.mapIndexed { index, name ->\n      Student(index, name)\n    }\n  students eq listOf(Student(0, "Alice"),\n    Student(1, "Bob"))\n  names.mapIndexed(::Student) eq students\n}\n')])])]),t("p",[t("code",[e._v("mapIndexed()")]),e._v(" was introduced in [Lambdas](javascript:void(0)). It turns each element in "),t("code",[e._v("names")]),e._v(" into the index of that element along with the element. In the definition of "),t("code",[e._v("students")]),e._v(", these are explicitly mapped into the constructor, but the identical effect is achieved with "),t("code",[e._v("names.mapIndexed(::Student)")]),e._v(". Thus, function and constructor references can eliminate specifying a long list of parameters that are simply passed into a lambda. Function and constructor references are often more readable than lambdas.")]),e._v(" "),t("h3",{attrs:{id:"extension-function-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extension-function-references"}},[e._v("#")]),e._v(" Extension Function References")]),e._v(" "),t("p",[e._v("To produce a reference to an extension function, prefix the reference with the name of the extended type:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// MemberReferences/ExtensionReference.kt\npackage memberreferences\nimport atomictest.eq\n\nfun Int.times47() = times(47)\n\nclass Frog\nfun Frog.speak() = "Ribbit!"\n\nfun goInt(n: Int, g: (Int) -> Int) = g(n)\n\nfun goFrog(frog: Frog, g: (Frog) -> String) =\n  g(frog)\n\nfun main() {\n  goInt(12, Int::times47) eq 564\n  goFrog(Frog(), Frog::speak) eq "Ribbit!"\n}\n')])])]),t("p",[e._v("In "),t("code",[e._v("goInt()")]),e._v(", "),t("code",[e._v("g")]),e._v(" is a function that expects an "),t("code",[e._v("Int")]),e._v(" argument and produces an "),t("code",[e._v("Int")]),e._v(". In "),t("code",[e._v("goFrog()")]),e._v(", "),t("code",[e._v("g")]),e._v(" expects a "),t("code",[e._v("Frog")]),e._v(" and produces a "),t("code",[e._v("String")]),e._v(".")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);