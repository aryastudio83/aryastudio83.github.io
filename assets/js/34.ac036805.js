(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{405:function(e,t,a){"use strict";a.r(t);var n=a(44),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"data-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-types"}},[e._v("#")]),e._v(" Data Types")]),e._v(" "),a("blockquote",[a("p",[e._v("Data can have different "),a("em",[e._v("types")]),e._v(".")])]),e._v(" "),a("p",[e._v("To solve a math problem, you write an expression:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("5.9 + 6\n")])])]),a("p",[e._v("You know that adding those numbers produces another number. Kotlin knows that too. You know that one is a fractional number ("),a("code",[e._v("5.9")]),e._v("), which Kotlin calls a "),a("code",[e._v("Double")]),e._v(", and the other is a whole number ("),a("code",[e._v("6")]),e._v("), which Kotlin calls an "),a("code",[e._v("Int")]),e._v(". You know the result is a fractional number.")]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("type")]),e._v(" (also called "),a("em",[e._v("data type")]),e._v(") tells Kotlin how you intend to use that data. A type provides a set of values from which an expression may take its values. A type defines the operations that can be performed on the data, the meaning of the data, and how values of that type can be stored.")]),e._v(" "),a("p",[e._v("Kotlin uses types to verify that your expressions are correct. In the above expression, Kotlin creates a new value of type "),a("code",[e._v("Double")]),e._v(" to hold the result.")]),e._v(" "),a("p",[e._v("Kotlin tries to adapt to what you need. If you ask it to do something that violates type rules it produces an error message. For example, try adding a "),a("code",[e._v("String")]),e._v(" and a number:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// DataTypes/StringPlusNumber.kt\n\nfun main() {\n  println("Sally" + 5.9)\n}\n/* Output:\nSally5.9\n*/\n')])])]),a("p",[e._v("Types tell Kotlin how to use them correctly. In this case, the type rules tell Kotlin how to add a number to a "),a("code",[e._v("String")]),e._v(": by appending the two values and creating a "),a("code",[e._v("String")]),e._v(" to hold the result.")]),e._v(" "),a("p",[e._v("Now try multiplying a "),a("code",[e._v("String")]),e._v(" and a "),a("code",[e._v("Double")]),e._v(" by changing the "),a("code",[e._v("+")]),e._v(" in "),a("code",[e._v("StringPlusNumber.kt")]),e._v(" to a "),a("code",[e._v("*")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('"Sally" * 5.9\n')])])]),a("p",[e._v("Combining types this way doesn’t make sense to Kotlin, so it gives you an error.")]),e._v(" "),a("p",[e._v("In ["),a("code",[e._v("var")]),e._v(" & "),a("code",[e._v("val")]),e._v("](javascript:void(0)), we stored several types. Kotlin figured out the types for us, based on how we used them. This is called "),a("em",[e._v("type inference")]),e._v(".")]),e._v(" "),a("p",[e._v("We can be more verbose and specify the type:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("val identifier: Type = initialization\n")])])]),a("p",[e._v("You start with the "),a("code",[e._v("val")]),e._v(" or "),a("code",[e._v("var")]),e._v(" keyword, followed by the identifier, a colon, the type, an "),a("code",[e._v("=")]),e._v(", and the initialization value. So instead of saying:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("val n = 1\nvar p = 1.2\n")])])]),a("p",[e._v("You can say:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("val n: Int = 1\nvar p: Double = 1.2\n")])])]),a("p",[e._v("We’ve told Kotlin that "),a("code",[e._v("n")]),e._v(" is an "),a("code",[e._v("Int")]),e._v(" and "),a("code",[e._v("p")]),e._v(" is a "),a("code",[e._v("Double")]),e._v(", rather than letting it infer the type.")]),e._v(" "),a("p",[e._v("Here are some of Kotlin’s basic types:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// DataTypes/Types.kt\n\nfun main() {\n  val whole: Int = 11              // [1]\n  val fractional: Double = 1.4     // [2]\n  val trueOrFalse: Boolean = true  // [3]\n  val words: String = "A value"    // [4]\n  val character: Char = \'z\'        // [5]\n  val lines: String = """Triple quotes let\nyou have many lines\nin your string"""                  // [6]\n  println(whole)\n  println(fractional)\n  println(trueOrFalse)\n  println(words)\n  println(character)\n  println(lines)\n}\n/* Output:\n11\n1.4\ntrue\nA value\nz\nTriple quotes let\nyou have many lines\nin your string\n*/\n')])])]),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" The "),a("code",[e._v("Int")]),e._v(" data type is an "),a("em",[e._v("integer")]),e._v(", which means it only holds whole numbers.")]),e._v(" "),a("li",[a("strong",[e._v("[2]")]),e._v(" To hold fractional numbers, use a "),a("code",[e._v("Double")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("[3]")]),e._v(" A "),a("code",[e._v("Boolean")]),e._v(" data type only holds the two special values "),a("code",[e._v("true")]),e._v(" and "),a("code",[e._v("false")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("[4]")]),e._v(" A "),a("code",[e._v("String")]),e._v(" holds a sequence of characters. You assign a value using a double-quoted "),a("code",[e._v("String")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("[5]")]),e._v(" A "),a("code",[e._v("Char")]),e._v(" holds one character.")]),e._v(" "),a("li",[a("strong",[e._v("[6]")]),e._v(" If you have many lines and/or special characters, surround them with triple-double-quotes (this is a "),a("em",[e._v("triple-quoted "),a("code",[e._v("String")])]),e._v(").")])]),e._v(" "),a("p",[e._v("Kotlin uses type inference to determine the meaning of mixed types. When mixing "),a("code",[e._v("Int")]),e._v("s and "),a("code",[e._v("Double")]),e._v("s during addition, for example, Kotlin decides the type for the resulting value:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// DataTypes/Inference.kt\n\nfun main() {\n  val n = 1 + 1.2\n  println(n)\n}\n/* Output:\n2.2\n*/\n")])])]),a("p",[e._v("When you add an "),a("code",[e._v("Int")]),e._v(" to a "),a("code",[e._v("Double")]),e._v(" using type inference, Kotlin determines that the result "),a("code",[e._v("n")]),e._v(" is a "),a("code",[e._v("Double")]),e._v(" and ensures that it follows all the rules for "),a("code",[e._v("Double")]),e._v("s.")]),e._v(" "),a("p",[e._v("Kotlin’s type inference is part of its strategy of doing work for the programmer. If you leave out the type declaration, Kotlin can usually infer it.")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);