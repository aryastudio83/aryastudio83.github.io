(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{562:function(e,t,n){"use strict";n.r(t);var o=n(44),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"class-delegation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#class-delegation"}},[e._v("#")]),e._v(" Class Delegation")]),e._v(" "),n("blockquote",[n("p",[e._v("Both composition and inheritance place subobjects inside your new class. With composition the subobject is explicit and with inheritance it is implicit.")])]),e._v(" "),n("p",[e._v("Composition uses the functionality of an embedded object but does not expose its interface. For a class to reuse an existing implementation "),n("em",[e._v("and")]),e._v(" implement its interface, you have two options: inheritance and "),n("em",[e._v("class delegation")]),e._v(".")]),e._v(" "),n("p",[e._v("Class delegation is midway between inheritance and composition. Like composition, you place a member object in the class you’re building. Like inheritance, class delegation exposes the interface of the subobject. In addition, you can upcast to the member type. For code reuse, class delegation makes composition as powerful as inheritance.")]),e._v(" "),n("p",[e._v("How would you achieve this without language support? Here, a spaceship needs a control module:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// ClassDelegation/SpaceShipControls.kt\npackage classdelegation\n\ninterface Controls {\n  fun up(velocity: Int): String\n  fun down(velocity: Int): String\n  fun left(velocity: Int): String\n  fun right(velocity: Int): String\n  fun forward(velocity: Int): String\n  fun back(velocity: Int): String\n  fun turboBoost(): String\n}\n\nclass SpaceShipControls : Controls {\n  override fun up(velocity: Int) =\n    "up $velocity"\n  override fun down(velocity: Int) =\n    "down $velocity"\n  override fun left(velocity: Int) =\n    "left $velocity"\n  override fun right(velocity: Int) =\n    "right $velocity"\n  override fun forward(velocity: Int) =\n    "forward $velocity"\n  override fun back(velocity: Int) =\n    "back $velocity"\n  override fun turboBoost() = "turbo boost"\n}\n')])])]),n("p",[e._v("If we want to expand the functionality of the controls or adjust some commands, we might try inheriting from "),n("code",[e._v("SpaceShipControls")]),e._v(". This doesn’t work because "),n("code",[e._v("SpaceShipControls")]),e._v(" is not "),n("code",[e._v("open")]),e._v(".")]),e._v(" "),n("p",[e._v("To expose the member functions in "),n("code",[e._v("Controls")]),e._v(", you can create an instance of "),n("code",[e._v("SpaceShipControls")]),e._v(" as a property and explicitly delegate all the exposed member functions to that instance:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// ClassDelegation/ExplicitDelegation.kt\npackage classdelegation\nimport atomictest.eq\n\nclass ExplicitControls : Controls {\n  private val controls = SpaceShipControls()\n  // Delegation by hand:\n  override fun up(velocity: Int) =\n    controls.up(velocity)\n  override fun back(velocity: Int) =\n    controls.back(velocity)\n  override fun down(velocity: Int) =\n    controls.down(velocity)\n  override fun forward(velocity: Int) =\n    controls.forward(velocity)\n  override fun left(velocity: Int) =\n    controls.left(velocity)\n  override fun right(velocity: Int) =\n    controls.right(velocity)\n  // Modified implementation:\n  override fun turboBoost(): String =\n    controls.turboBoost() + "... boooooost!"\n}\n\nfun main() {\n  val controls = ExplicitControls()\n  controls.forward(100) eq "forward 100"\n  controls.turboBoost() eq\n    "turbo boost... boooooost!"\n}\n')])])]),n("p",[e._v("The functions are forwarded to the underlying "),n("code",[e._v("controls")]),e._v(" object, and the resulting interface is the same as if you had used regular inheritance. You can also provide implementation changes, as with "),n("code",[e._v("turboBoost()")]),e._v(".")]),e._v(" "),n("p",[e._v("Kotlin automates the process of class delegation, so instead of writing explicit function implementations as in "),n("code",[e._v("ExplicitDelegation.kt")]),e._v(", you specify an object to use as a delegate.")]),e._v(" "),n("p",[e._v("To delegate to a class, place the "),n("code",[e._v("by")]),e._v(" keyword after the interface name, followed by the member property to use as the delegate:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// ClassDelegation/BasicDelegation.kt\npackage classdelegation\n\ninterface AI\nclass A : AI\n\nclass B(val a: A) : AI by a\n")])])]),n("p",[e._v("Read this as “class "),n("code",[e._v("B")]),e._v(" implements interface "),n("code",[e._v("AI")]),e._v(" "),n("em",[e._v("by")]),e._v(" using the "),n("code",[e._v("a")]),e._v(" member object.” You can only delegate to interfaces, so you can’t say "),n("code",[e._v("A by a")]),e._v(". The delegate object ("),n("code",[e._v("a")]),e._v(") must be a constructor argument.")]),e._v(" "),n("p",[n("code",[e._v("ExplicitDelegation.kt")]),e._v(" can now be rewritten using "),n("code",[e._v("by")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// ClassDelegation/DelegatedControls.kt\npackage classdelegation\nimport atomictest.eq\n\nclass DelegatedControls(\n  private val controls: SpaceShipControls =\n    SpaceShipControls()\n): Controls by controls {\n  override fun turboBoost(): String =\n    "${controls.turboBoost()}... boooooost!"\n}\n\nfun main() {\n  val controls = DelegatedControls()\n  controls.forward(100) eq "forward 100"\n  controls.turboBoost() eq\n    "turbo boost... boooooost!"\n}\n')])])]),n("p",[e._v("When Kotlin sees the "),n("code",[e._v("by")]),e._v(" keyword, it generates code similar to what we wrote for "),n("code",[e._v("ExplicitDelegation.kt")]),e._v(". After delegation, the functions of the member object are accessible via the outer object, but without writing all that extra code.")]),e._v(" "),n("p",[e._v("Kotlin doesn’t support multiple class inheritance, but you can simulate it using class delegation. In general, multiple inheritance is used to combine classes that have completely different functionality. For example, suppose you want to produce a button by combining a class that draws a rectangle on the screen with a class that manages mouse events:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// ClassDelegation/ModelingMI.kt\npackage classdelegation\nimport atomictest.eq\n\ninterface Rectangle {\n  fun paint(): String\n}\n\nclass ButtonImage(\n  val width: Int,\n  val height: Int\n): Rectangle {\n  override fun paint() =\n    "painting ButtonImage($width, $height)"\n}\n\ninterface MouseManager {\n  fun clicked(): Boolean\n  fun hovering(): Boolean\n}\n\nclass UserInput : MouseManager {\n  override fun clicked() = true\n  override fun hovering() = true\n}\n\n// Even if we make the classes open, we\n// get an error because only one class may\n// appear in a supertype list:\n// class Button : ButtonImage(), UserInput()\n\nclass Button(\n  val width: Int,\n  val height: Int,\n  var image: Rectangle =\n    ButtonImage(width, height),\n  private var input: MouseManager = UserInput()\n): Rectangle by image, MouseManager by input\n\nfun main() {\n  val button = Button(10, 5)\n  button.paint() eq\n    "painting ButtonImage(10, 5)"\n  button.clicked() eq true\n  button.hovering() eq true\n  // Can upcast to both delegated types:\n  val rectangle: Rectangle = button\n  val mouseManager: MouseManager = button\n}\n')])])]),n("p",[e._v("The class "),n("code",[e._v("Button")]),e._v(" implements two interfaces: "),n("code",[e._v("Rectangle")]),e._v(" and "),n("code",[e._v("MouseManager")]),e._v(". It can’t inherit from implementations of both "),n("code",[e._v("ButtonImage")]),e._v(" and "),n("code",[e._v("UserInput")]),e._v(", but it can delegate to both of them.")]),e._v(" "),n("p",[e._v("Notice that the definition for "),n("code",[e._v("image")]),e._v(" in the constructor argument list is both "),n("code",[e._v("public")]),e._v(" and a "),n("code",[e._v("var")]),e._v(". This allows the client programmer to dynamically replace the "),n("code",[e._v("ButtonImage")]),e._v(".")]),e._v(" "),n("p",[e._v("The last two lines in "),n("code",[e._v("main()")]),e._v(" show that a "),n("code",[e._v("Button")]),e._v(" can be upcast to both of its delegated types. This was the goal of multiple inheritance, so delegation effectively solves the need for multiple inheritance.")]),e._v(" "),n("ul",[n("li",[e._v("-")])]),e._v(" "),n("p",[e._v("Inheritance can be constraining. For example, you cannot inherit a class when the superclass is not "),n("code",[e._v("open")]),e._v(", or if your new class is already extending another class. Class delegation releases you from these and other limitations.")]),e._v(" "),n("p",[e._v("Use class delegation with care. Among the three choices—inheritance, composition and class delegation—try composition first. It’s the simplest approach and solves the majority of use cases. Inheritance is necessary when you need a hierarchy of types, to create relationships between those types. Class delegation can work when those options don’t.")]),e._v(" "),n("p",[n("em",[n("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);