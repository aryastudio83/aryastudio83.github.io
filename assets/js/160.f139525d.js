(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{539:function(e,n,o){"use strict";o.r(n);var t=o(44),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"break-continue"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#break-continue"}},[e._v("#")]),e._v(" "),o("code",[e._v("break")]),e._v(" & "),o("code",[e._v("continue")])]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" allow you to “jump” within a loop.")])]),e._v(" "),o("p",[e._v("Early programmers wrote directly to the processor, using either numerical "),o("em",[e._v("opcodes")]),e._v(" as instructions, or "),o("em",[e._v("assembly language")]),e._v(", which translates into opcodes. This kind of programming is as low-level as you can get. For example, many coding decisions were facilitated by “jumping” directly to other places in the code. Early higher-level languages (including FORTRAN, ALGOL, Pascal, C and C++) duplicated this practice by implementing a "),o("code",[e._v("goto")]),e._v(" keyword.")]),e._v(" "),o("p",[o("code",[e._v("goto")]),e._v(" made assembly-language programmers more comfortable as they transitioned to higher-level languages. As we accumulated more experience, however, the programming community discovered that unconditional jumps produce complicated and un-maintainable code. This generated a large backlash against "),o("code",[e._v("goto")]),e._v(", and most subsequent languages have avoided any kind of unconditional jump.")]),e._v(" "),o("p",[e._v("Kotlin provides a "),o("em",[e._v("constrained jump")]),e._v(" in the form of "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(". These are tied to the looping constructs "),o("code",[e._v("for")]),e._v(", "),o("code",[e._v("while")]),e._v(" and "),o("code",[e._v("do-while")]),e._v("—you can only use "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" from within such loops. In addition, "),o("code",[e._v("continue")]),e._v(" can only jump to the beginning of a loop, and "),o("code",[e._v("break")]),e._v(" can only jump to the end of a loop.")]),e._v(" "),o("p",[e._v("In practice you rarely use "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" when writing new Kotlin code. These features are artifacts from earlier languages. Although they are occasionally useful, you’ll learn in this book that Kotlin provides superior mechanisms.")]),e._v(" "),o("p",[e._v("Here’s an example with a "),o("code",[e._v("for")]),e._v(" loop containing both a "),o("code",[e._v("continue")]),e._v(" and a "),o("code",[e._v("break")]),e._v(":")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// BreakAndContinue/ForControl.kt\nimport atomictest.eq\n\nfun main() {\n  val nums = mutableListOf(0)\n  for (i in 4 until 100 step 4) { // [1]\n    if (i == 8) continue          // [2]\n    if (i == 40) break            // [3]\n    nums.add(i)\n  }                               // [4]\n  nums eq "[0, 4, 12, 16, 20, 24, 28, 32, 36]"\n}\n')])])]),o("p",[e._v("The example aggregates "),o("code",[e._v("Int")]),e._v("s into a mutable "),o("code",[e._v("List")]),e._v(". The "),o("code",[e._v("continue")]),e._v(" at "),o("strong",[e._v("[2]")]),e._v(" jumps back to the beginning of the loop, which is the opening brace at "),o("strong",[e._v("[1]")]),e._v(". It “continues” execution starting with the next iteration of the loop. Note that the code following "),o("code",[e._v("continue")]),e._v(" inside the "),o("code",[e._v("for")]),e._v(" loop body is "),o("em",[e._v("not")]),e._v(" executed: "),o("code",[e._v("nums.add(i)")]),e._v(" is not called when "),o("code",[e._v("i == 8")]),e._v(" so you don’t see it in the resulting "),o("code",[e._v("nums")]),e._v(".")]),e._v(" "),o("p",[e._v("When "),o("code",[e._v("i == 40")]),e._v(", "),o("code",[e._v("break")]),e._v(" is executed at "),o("strong",[e._v("[3]")]),e._v(", which “breaks out” of the "),o("code",[e._v("for")]),e._v(" loop by jumping to the end of its scope at "),o("strong",[e._v("[4]")]),e._v(". The numbers beginning at "),o("code",[e._v("40")]),e._v(" are not added to the resulting "),o("code",[e._v("List")]),e._v(" because the "),o("code",[e._v("for")]),e._v(" loop stops executing.")]),e._v(" "),o("p",[e._v("Lines "),o("strong",[e._v("[2]")]),e._v(" and "),o("strong",[e._v("[3]")]),e._v(" are interchangeable because their logic doesn’t overlap. Try swapping the lines and verify that the output doesn’t change.")]),e._v(" "),o("p",[e._v("We can rewrite "),o("code",[e._v("ForControl.kt")]),e._v(" using a "),o("code",[e._v("while")]),e._v(" loop:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// BreakAndContinue/WhileControl.kt\nimport atomictest.eq\n\nfun main() {\n  val nums = mutableListOf(0)\n  var i = 0\n  while (i < 100) {\n    i += 4\n    if (i == 8) continue\n    if (i == 40) break\n    nums.add(i)\n  }\n  nums eq "[0, 4, 12, 16, 20, 24, 28, 32, 36]"\n}\n')])])]),o("p",[e._v("The "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" behavior remains the same, as it does for a "),o("code",[e._v("do")]),e._v("-"),o("code",[e._v("while")]),e._v(" loop:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// BreakAndContinue/DoWhileControl.kt\nimport atomictest.eq\n\nfun main() {\n  val nums = mutableListOf(0)\n  var i = 0\n  do {\n    i += 4\n    if (i == 8) continue\n    if (i == 40) break\n    nums.add(i)\n  } while (i < 100)\n  nums eq "[0, 4, 12, 16, 20, 24, 28, 32, 36]"\n}\n')])])]),o("p",[e._v("A "),o("code",[e._v("do")]),e._v("-"),o("code",[e._v("while")]),e._v(" loop always executes at least once, because the "),o("code",[e._v("while")]),e._v(" test is at the end of the loop.")]),e._v(" "),o("h3",{attrs:{id:"labels"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#labels"}},[e._v("#")]),e._v(" Labels")]),e._v(" "),o("p",[e._v("Plain "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" can jump no further than the boundaries of their local loop. "),o("em",[e._v("Labels")]),e._v(" allow "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" to jump to the boundaries of "),o("em",[e._v("enclosing")]),e._v(" loops, so you aren’t limited to the scope of the current loop.")]),e._v(" "),o("p",[e._v("You create a label by using "),o("code",[e._v("label@")]),e._v(", where "),o("code",[e._v("label")]),e._v(" can be any name. Here, the label is "),o("code",[e._v("outer")]),e._v(":")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// BreakAndContinue/ForLabeled.kt\nimport atomictest.eq\n\nfun main() {\n  val strings = mutableListOf<String>()\n  outer@ for (c in \'a\'..\'e\') {\n    for (i in 1..9) {\n      if (i == 5) continue@outer\n      if ("$c$i" == "c3") break@outer\n      strings.add("$c$i")\n    }\n  }\n  strings eq listOf("a1", "a2", "a3", "a4",\n    "b1", "b2", "b3", "b4", "c1", "c2")\n}\n')])])]),o("p",[e._v("The labeled "),o("code",[e._v("continue")]),e._v(" expression "),o("code",[e._v("continue@outer")]),e._v(" continues back to the label "),o("code",[e._v("outer@")]),e._v(". The labeled "),o("code",[e._v("break")]),e._v(" expression "),o("code",[e._v("break@outer")]),e._v(" finds the end of the block named "),o("code",[e._v("outer@")]),e._v(", and proceeds from there.")]),e._v(" "),o("p",[e._v("Labels work with "),o("code",[e._v("while")]),e._v(" and "),o("code",[e._v("do")]),e._v("-"),o("code",[e._v("while")]),e._v(":")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// BreakAndContinue/WhileLabeled.kt\nimport atomictest.eq\n\nfun main() {\n  val strings = mutableListOf<String>()\n  var c = \'a\' - 1\n  outer@ while (c < \'f\') {\n    c += 1\n    var i = 0\n    do {\n      i++\n      if (i == 5) continue@outer\n      if ("$c$i" == "c3") break@outer\n      strings.add("$c$i")\n    } while (i < 10)\n  }\n  strings eq listOf("a1", "a2", "a3", "a4",\n    "b1", "b2", "b3", "b4", "c1", "c2")\n}\n')])])]),o("p",[o("code",[e._v("WhileLabeled.kt")]),e._v(" can be rewritten as:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// BreakAndContinue/Improved.kt\nimport atomictest.eq\n\nfun main() {\n  val strings = mutableListOf<String>()\n  for (c in \'a\'..\'c\') {\n    for (i in 1..4) {\n      val value = "$c$i"\n      if (value < "c3") {     // [1]\n        strings.add(value)\n      }\n    }\n  }\n  strings eq listOf("a1", "a2", "a3", "a4",\n    "b1", "b2", "b3", "b4", "c1", "c2")\n}\n')])])]),o("p",[e._v("This is far more comprehensible. In line "),o("strong",[e._v("[1]")]),e._v(", we only add "),o("code",[e._v("String")]),e._v("s that occur (alphabetically) before "),o("code",[e._v('"c3"')]),e._v(". This produces the same behavior as using "),o("code",[e._v("break")]),e._v(" when reaching "),o("code",[e._v('"c3"')]),e._v(" in the previous versions of the example.")]),e._v(" "),o("ul",[o("li",[e._v("-")])]),e._v(" "),o("p",[o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" tend to create complicated and un-maintainable code. Although these jumps are somewhat more civilized than “goto,” they still interrupt program flow. Code without jumps is almost always easier to understand.")]),e._v(" "),o("p",[e._v("In some cases, you can write the conditions for iteration explicitly instead of using "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(", as we did in the example above. In other cases, you can restructure your code and introduce new functions. Both "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(" can be replaced with "),o("code",[e._v("return")]),e._v(" if you extract the whole loop or the loop body into new functions. In the next section, [Functional Programming](javascript:void(0)), you’ll learn to write clear code without using "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(".")]),e._v(" "),o("p",[e._v("Consider alternative approaches, and choose the simpler and more readable solution. This typically won’t include "),o("code",[e._v("break")]),e._v(" and "),o("code",[e._v("continue")]),e._v(".")]),e._v(" "),o("p",[o("em",[o("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);