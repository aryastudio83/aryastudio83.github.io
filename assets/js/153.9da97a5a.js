(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{533:function(e,t,a){"use strict";a.r(t);var n=a(44),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"destructuring-declarations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#destructuring-declarations"}},[e._v("#")]),e._v(" Destructuring Declarations")]),e._v(" "),a("blockquote",[a("p",[e._v("Suppose you want to return more than one item from a function, such as a result along with some information about that result.")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("Pair")]),e._v(" class, which is part of the standard library, allows you to return two values:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Destructuring/Pairs.kt\npackage destructuring\nimport atomictest.eq\n\nfun compute(input: Int): Pair<Int, String> =\n  if (input > 5)\n    Pair(input * 2, "High")\n  else\n    Pair(input * 2, "Low")\n\nfun main() {\n  compute(7) eq Pair(14, "High")\n  compute(4) eq Pair(8, "Low")\n  val result = compute(5)\n  result.first eq 10\n  result.second eq "Low"\n}\n')])])]),a("p",[e._v("We specify the return type of "),a("code",[e._v("compute()")]),e._v(" as "),a("code",[e._v("Pair<Int, String>")]),e._v(". A "),a("code",[e._v("Pair")]),e._v(" is a parameterized type, like "),a("code",[e._v("List")]),e._v(" or "),a("code",[e._v("Set")]),e._v(".")]),e._v(" "),a("p",[e._v("Returning multiple values is helpful, but we’d also like a convenient way to unpack the results. As shown above, you can access the components of a "),a("code",[e._v("Pair")]),e._v(" using its "),a("code",[e._v("first")]),e._v(" and "),a("code",[e._v("second")]),e._v(" properties, but you can also declare and initialize several identifiers simultaneously using a "),a("em",[e._v("destructuring declaration")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("val (a, b, c) = composedValue\n")])])]),a("p",[e._v("This destructures a composed value and positionally assigns its components. The syntax differs from defining a single identifier—for destructuring, you put the names of the identifiers inside parentheses.")]),e._v(" "),a("p",[e._v("Here’s a destructuring declaration for the "),a("code",[e._v("Pair")]),e._v(" returned from "),a("code",[e._v("compute()")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Destructuring/PairDestructuring.kt\nimport destructuring.compute\nimport atomictest.eq\n\nfun main() {\n  val (value, description) = compute(7)\n  value eq 14\n  description eq "High"\n}\n')])])]),a("p",[e._v("The "),a("code",[e._v("Triple")]),e._v(" class combines three values, but that’s as far as it goes. This is intentional: if you need to store more values, or if you find yourself using many "),a("code",[e._v("Pair")]),e._v("s or "),a("code",[e._v("Triple")]),e._v("s, consider creating special classes instead.")]),e._v(" "),a("p",[e._v("["),a("code",[e._v("data")]),e._v(" Classes](javascript:void(0)) automatically allow destructuring declarations:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Destructuring/Computation.kt\npackage destructuring\nimport atomictest.eq\n\ndata class Computation(\n  val data: Int,\n  val info: String\n)\n\nfun evaluate(input: Int) =\n  if (input > 5)\n    Computation(input * 2, "High")\n  else\n    Computation(input * 2, "Low")\n\nfun main() {\n  val (value, description) = evaluate(7)\n  value eq 14\n  description eq "High"\n}\n')])])]),a("p",[e._v("It’s clearer to return a "),a("code",[e._v("Computation")]),e._v(" instead of a "),a("code",[e._v("Pair<Int, String>")]),e._v(". Choosing a good name for the result is almost as important as choosing a good self-explanatory name for the function itself. Adding or removing "),a("code",[e._v("Computation")]),e._v(" information is simpler if it’s a separate class rather than a "),a("code",[e._v("Pair")]),e._v(".")]),e._v(" "),a("p",[e._v("When you unpack an instance of a "),a("code",[e._v("data")]),e._v(" class, you must assign values to the new identifiers in the same order you define the properties in the class:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Destructuring/Tuple.kt\npackage destructuring\nimport atomictest.eq\n\ndata class Tuple(\n  val i: Int,\n  val d: Double,\n  val s: String,\n  val b: Boolean,\n  val l: List<Int>\n)\n\nfun main() {\n  val tuple = Tuple(\n    1, 3.14, "Mouse", false, listOf())\n  val (i, d, s, b, l) = tuple\n  i eq 1\n  d eq 3.14\n  s eq "Mouse"\n  b eq false\n  l eq listOf()\n\n  val (_, _, animal) = tuple   // [1]\n  animal eq "Mouse"\n}\n')])])]),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" If you don’t need some of the identifiers, you may use underscores instead of their names, or omit them completely if they appear at the end. Here, the unpacked values "),a("code",[e._v("1")]),e._v(" and "),a("code",[e._v("3.14")]),e._v(" are discarded using underscores, "),a("code",[e._v('"Mouse"')]),e._v(" is captured into "),a("code",[e._v("animal")]),e._v(", and "),a("code",[e._v("false")]),e._v(" and the empty "),a("code",[e._v("List")]),e._v(" are discarded because they are at the end of the list.")])]),e._v(" "),a("p",[e._v("The properties of a "),a("code",[e._v("data")]),e._v(" class are assigned by order, not by name. If you destructure an object and later add a property anywhere except the end of its "),a("code",[e._v("data")]),e._v(" class, that new property will be destructured on top of your previous identifier, producing unexpected results (see Exercise 3). If your custom "),a("code",[e._v("data")]),e._v(" class has properties with identical types, the compiler can’t detect misuse so you may want to avoid destructuring it. Destructuring library "),a("code",[e._v("data")]),e._v(" classes like "),a("code",[e._v("Pair")]),e._v(" or "),a("code",[e._v("Triple")]),e._v(" is safe, because they don’t change.")]),e._v(" "),a("p",[e._v("Using a "),a("code",[e._v("for")]),e._v(" loop, you can iterate over a "),a("code",[e._v("Map")]),e._v(" or a "),a("code",[e._v("List")]),e._v(" of pairs (or other "),a("code",[e._v("data")]),e._v(" classes) and destructure each element:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Destructuring/ForLoop.kt\nimport atomictest.eq\n\nfun main() {\n  var result = ""\n  val map = mapOf(1 to "one", 2 to "two")\n  for ((key, value) in map) {\n    result += "$key = $value, "\n  }\n  result eq "1 = one, 2 = two,"\n\n  result = ""\n  val listOfPairs =\n    listOf(Pair(1, "one"), Pair(2, "two"))\n  for ((i, s) in listOfPairs) {\n    result += "($i, $s), "\n  }\n  result eq "(1, one), (2, two),"\n}\n')])])]),a("p",[a("code",[e._v("withIndex()")]),e._v(" is a standard library extension function for "),a("code",[e._v("List")]),e._v(". It returns a collection of "),a("code",[e._v("IndexedValue")]),e._v("s, which can be destructured:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Destructuring/LoopWithIndex.kt\nimport atomictest.trace\n\nfun main() {\n  val list = listOf('a', 'b', 'c')\n  for ((index, value) in list.withIndex()) {\n    trace(\"$index:$value\")\n  }\n  trace eq \"0:a 1:b 2:c\"\n}\n")])])]),a("p",[e._v("Destructuring declarations are only allowed for local "),a("code",[e._v("var")]),e._v("s and "),a("code",[e._v("val")]),e._v("s, and cannot be used to create class properties.")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);