(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{473:function(e,s,a){"use strict";a.r(s);var t=a(44),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"sealed-classes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sealed-classes"}},[e._v("#")]),e._v(" Sealed Classes")]),e._v(" "),a("blockquote",[a("p",[e._v("To constrain a class hierarchy, declare the superclass "),a("code",[e._v("sealed")]),e._v(".")])]),e._v(" "),a("p",[e._v("Consider a trip taken by travelers using different modes of transportation:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SealedClasses/UnSealed.kt\npackage withoutsealedclasses\nimport atomictest.eq\n\nopen class Transport\n\ndata class Train(\n  val line: String\n): Transport()\n\ndata class Bus(\n  val number: String,\n  val capacity: Int\n): Transport()\n\nfun travel(transport: Transport) =\n  when (transport) {\n    is Train ->\n      "Train ${transport.line}"\n    is Bus ->\n      "Bus ${transport.number}: " +\n      "size ${transport.capacity}"\n    else -> "$transport is in limbo!"\n  }\n\nfun main() {\n  listOf(Train("S1"), Bus("11", 90))\n    .map(::travel) eq\n    "[Train S1, Bus 11: size 90]"\n}\n')])])]),a("p",[a("code",[e._v("Train")]),e._v(" and "),a("code",[e._v("Bus")]),e._v(" each contain different details about their "),a("code",[e._v("Transport")]),e._v(" mode.")]),e._v(" "),a("p",[a("code",[e._v("travel()")]),e._v(" contains a "),a("code",[e._v("when")]),e._v(" expression that discovers the exact type of the "),a("code",[e._v("transport")]),e._v(" parameter. Kotlin requires the default "),a("code",[e._v("else")]),e._v(" branch, because there might be other subclasses of "),a("code",[e._v("Transport")]),e._v(".")]),e._v(" "),a("p",[a("code",[e._v("travel()")]),e._v(" shows downcasting’s inherent trouble spot. Suppose you inherit "),a("code",[e._v("Tram")]),e._v(" as a new type of "),a("code",[e._v("Transport")]),e._v(". If you do this, "),a("code",[e._v("travel()")]),e._v(" continues to compile and run, giving you no clue that you should modify it to detect "),a("code",[e._v("Tram")]),e._v(". If you have many instances of downcasting scattered throughout your code, this becomes a maintenance challenge.")]),e._v(" "),a("p",[e._v("We can improve the situation using the "),a("code",[e._v("sealed")]),e._v(" keyword. When defining "),a("code",[e._v("Transport")]),e._v(", replace "),a("code",[e._v("open class")]),e._v(" with "),a("code",[e._v("sealed class")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SealedClasses/SealedClasses.kt\npackage sealedclasses\nimport atomictest.eq\n\nsealed class Transport\n\ndata class Train(\n  val line: String\n) : Transport()\n\ndata class Bus(\n  val number: String,\n  val capacity: Int\n) : Transport()\n\nfun travel(transport: Transport) =\n  when (transport) {\n    is Train ->\n      "Train ${transport.line}"\n    is Bus ->\n      "Bus ${transport.number}: " +\n      "size ${transport.capacity}"\n  }\n\nfun main() {\n  listOf(Train("S1"), Bus("11", 90))\n    .map(::travel) eq\n    "[Train S1, Bus 11: size 90]"\n}\n')])])]),a("p",[e._v("All direct subclasses of a "),a("code",[e._v("sealed")]),e._v(" class must be located in the same file as the base class.")]),e._v(" "),a("p",[e._v("Although Kotlin forces you to exhaustively check all possible types in a "),a("code",[e._v("when")]),e._v(" expression, the "),a("code",[e._v("when")]),e._v(" in "),a("code",[e._v("travel()")]),e._v(" no longer requires an "),a("code",[e._v("else")]),e._v(" branch. Because "),a("code",[e._v("Transport")]),e._v(" is "),a("code",[e._v("sealed")]),e._v(", Kotlin knows that no additional subclasses of "),a("code",[e._v("Transport")]),e._v(" exist other than the ones present in this file. The "),a("code",[e._v("when")]),e._v(" expression is now exhaustive without an "),a("code",[e._v("else")]),e._v(" branch.")]),e._v(" "),a("p",[a("code",[e._v("sealed")]),e._v(" hierarchies discover errors when adding new subclasses. When you introduce a new subclass, you must update all the code that uses the existing hierarchy. The "),a("code",[e._v("travel()")]),e._v(" function in "),a("code",[e._v("UnSealed.kt")]),e._v(" will continue to work because the "),a("code",[e._v("else")]),e._v(" branch produces "),a("code",[e._v('"$transport is in limbo!"')]),e._v(" on unknown types of transportation. However, that’s probably not the behavior you want.")]),e._v(" "),a("p",[e._v("A "),a("code",[e._v("sealed")]),e._v(" class reveals all the places to modify when we add a new subclass such as "),a("code",[e._v("Tram")]),e._v(". The "),a("code",[e._v("travel()")]),e._v(" function in "),a("code",[e._v("SealedClasses.kt")]),e._v(" won’t compile if we introduce the "),a("code",[e._v("Tram")]),e._v(" class without making additional changes. The "),a("code",[e._v("sealed")]),e._v(" keyword makes it impossible to ignore the problem, because you get a compilation error.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("sealed")]),e._v(" keyword makes downcasting more palatable, but you should still be suspicious of designs that make excessive use of downcasting. There is often a better and cleaner way to write that code using polymorphism.")]),e._v(" "),a("h3",{attrs:{id:"sealed-vs-abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sealed-vs-abstract"}},[e._v("#")]),e._v(" "),a("code",[e._v("sealed")]),e._v(" vs. "),a("code",[e._v("abstract")])]),e._v(" "),a("p",[e._v("Here we show that both "),a("code",[e._v("abstract")]),e._v(" and "),a("code",[e._v("sealed")]),e._v(" classes allow identical types of functions, properties, and constructors:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SealedClasses/SealedVsAbstract.kt\npackage sealedclasses\n\nabstract class Abstract(val av: String) {\n  open fun concreteFunction() {}\n  open val concreteProperty = ""\n  abstract fun abstractFunction(): String\n  abstract val abstractProperty: String\n  init {}\n  constructor(c: Char) : this(c.toString())\n}\n\nopen class Concrete() : Abstract("") {\n  override fun concreteFunction() {}\n  override val concreteProperty = ""\n  override fun abstractFunction() = ""\n  override val abstractProperty = ""\n}\n\nsealed class Sealed(val av: String) {\n  open fun concreteFunction() {}\n  open val concreteProperty = ""\n  abstract fun abstractFunction(): String\n  abstract val abstractProperty: String\n  init {}\n  constructor(c: Char) : this(c.toString())\n}\n\nopen class SealedSubclass() : Sealed("") {\n  override fun concreteFunction() {}\n  override val concreteProperty = ""\n  override fun abstractFunction() = ""\n  override val abstractProperty = ""\n}\n\nfun main() {\n  Concrete()\n  SealedSubclass()\n}\n')])])]),a("p",[e._v("A "),a("code",[e._v("sealed")]),e._v(" class is basically an "),a("code",[e._v("abstract")]),e._v(" class with the extra constraint that all direct subclasses must be defined within the same file.")]),e._v(" "),a("p",[e._v("Indirect subclasses of a sealed class can be defined in a separate file:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// SealedClasses/ThirdLevelSealed.kt\npackage sealedclasses\n\nclass ThirdLevel : SealedSubclass()\n")])])]),a("p",[a("code",[e._v("ThirdLevel")]),e._v(" doesn’t directly inherit from "),a("code",[e._v("Sealed")]),e._v(" so it doesn’t need to reside in "),a("code",[e._v("SealedVsAbstract.kt")]),e._v(".")]),e._v(" "),a("p",[e._v("Although a "),a("code",[e._v("sealed interface")]),e._v(" seems like it would be a useful construct, Kotlin doesn’t provide it because Java classes cannot be prevented from implementing the same interface.")]),e._v(" "),a("h3",{attrs:{id:"enumerating-subclasses"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enumerating-subclasses"}},[e._v("#")]),e._v(" Enumerating Subclasses")]),e._v(" "),a("p",[e._v("When a class is "),a("code",[e._v("sealed")]),e._v(", you can easily iterate through its subclasses:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SealedClasses/SealedSubclasses.kt\npackage sealedclasses\nimport atomictest.eq\n\nsealed class Top\nclass Middle1 : Top()\nclass Middle2 : Top()\nopen class Middle3 : Top()\nclass Bottom3 : Middle3()\n\nfun main() {\n  Top::class.sealedSubclasses\n    .map { it.simpleName } eq\n    "[Middle1, Middle2, Middle3]"\n}\n')])])]),a("p",[e._v("Creating a class generates a "),a("em",[e._v("class object")]),e._v(". You can access properties and member functions of that class object to discover information, and to create and manipulate objects of that class. "),a("code",[e._v("::class")]),e._v(" produces a class object, so "),a("code",[e._v("Top::class")]),e._v(" produces the class object for "),a("code",[e._v("Top")]),e._v(".")]),e._v(" "),a("p",[e._v("One of the properties of class objects is "),a("code",[e._v("sealedSubclasses")]),e._v(", which expects that "),a("code",[e._v("Top")]),e._v(" is a "),a("code",[e._v("sealed")]),e._v(" class (otherwise it produces an empty list). "),a("code",[e._v("sealedSubclasses")]),e._v(" produces all the class objects of those subclasses. Notice that only the immediate subclasses of "),a("code",[e._v("Top")]),e._v(" appear in the result.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("toString()")]),e._v(" for a class object is slightly verbose. We produce the class name alone by using the "),a("code",[e._v("simpleName")]),e._v(" property.")]),e._v(" "),a("p",[a("code",[e._v("sealedSubclasses")]),e._v(" uses "),a("em",[e._v("reflection")]),e._v(", which requires that the dependency "),a("code",[e._v("kotlin-reflection.jar")]),e._v(" be in the classpath. Reflection is a way to dynamically discover and use characteristics of a class.")]),e._v(" "),a("p",[a("code",[e._v("sealedSubclasses")]),e._v(" can be an important tool when building polymorphic systems. It can ensure that new classes will automatically be included in all appropriate operations. Because it discovers the subclasses at runtime, however, it may have a performance impact on your system. If you are having speed issues, be sure to use a profiler to discover whether "),a("code",[e._v("sealedSubclasses")]),e._v(" might be the problem (as you learn to use a profiler, you’ll discover that performance problems are usually "),a("em",[e._v("not")]),e._v(" where you guess them to be).")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);