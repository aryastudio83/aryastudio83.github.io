(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{424:function(e,t,n){"use strict";n.r(t);var o=n(44),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"testing"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#testing"}},[e._v("#")]),e._v(" Testing")]),e._v(" "),n("blockquote",[n("p",[e._v("Constant testing is essential for rapid program development.")])]),e._v(" "),n("p",[e._v("If changing one part of your code breaks other code, your tests reveal the problem right away. If you don’t find out immediately, changes accumulate and you can no longer tell which change caused the problem. You’ll spend a "),n("em",[e._v("lot")]),e._v(" longer tracking it down.")]),e._v(" "),n("p",[e._v("Testing is a crucial practice, so we introduce it early and use it throughout the rest of the book. This way, you become accustomed to testing as a standard part of the programming process.")]),e._v(" "),n("p",[e._v("Using "),n("code",[e._v("println()")]),e._v(" to verify code correctness is a weak approach—you must scrutinize the output every time and consciously ensure that it’s correct.")]),e._v(" "),n("p",[e._v("To simplify your experience while using this book, we created our own tiny testing system. The goal is a minimal approach that:")]),e._v(" "),n("ol",[n("li",[e._v("Shows the expected result of expressions.")]),e._v(" "),n("li",[e._v("Provides output so you know the program is running, even when all tests succeed.")]),e._v(" "),n("li",[e._v("Ingrains the concept of testing early in your practice.")])]),e._v(" "),n("p",[e._v("Although useful for this book, ours is "),n("em",[e._v("not")]),e._v(" a testing system for the workplace. Others have toiled long and hard to create such test systems. For example:")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://junit.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("JUnit"),n("OutboundLink")],1),e._v(" is one of the most popular Java test frameworks, and is easily used from within Kotlin.")]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/kotest/kotest",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kotest"),n("OutboundLink")],1),e._v(" is designed specifically for Kotlin, and takes advantage of Kotlin language features.")]),e._v(" "),n("li",[e._v("The "),n("a",{attrs:{href:"https://spekframework.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spek Framework"),n("OutboundLink")],1),e._v(" produces a different form of testing, called "),n("em",[e._v("Specification Testing")]),e._v(".")])]),e._v(" "),n("p",[e._v("To use our testing framework, we must first "),n("code",[e._v("import")]),e._v(" it. The basic elements of the framework are "),n("code",[e._v("eq")]),e._v(" ("),n("em",[e._v("equals")]),e._v(") and "),n("code",[e._v("neq")]),e._v(" ("),n("em",[e._v("not equals")]),e._v("):")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Testing/TestingExample.kt\nimport atomictest.*\n\nfun main() {\n  val v1 = 11\n  val v2 = "Ontology"\n\n  // \'eq\' means "equals":\n  v1 eq 11\n  v2 eq "Ontology"\n\n  // \'neq\' means "not equal"\n  v2 neq "Epistimology"\n\n  // [Error] Epistimology != Ontology\n  // v2 eq "Epistimology"\n}\n/* Output:\n11\nOntology\nOntology\n*/\n')])])]),n("p",[e._v("The code for the "),n("code",[e._v("atomictest")]),e._v(" package is in [Appendix A: AtomicTest](javascript:void(0)). We don’t intend that you understand everything in "),n("code",[e._v("AtomicTest.kt")]),e._v(" right now, because it uses some features that won’t appear until later in the book.")]),e._v(" "),n("p",[e._v("To produce a clean, comfortable appearance, "),n("code",[e._v("AtomicTest")]),e._v(" uses a Kotlin feature you haven’t seen yet: the ability to write a function call "),n("code",[e._v("a.function(b)")]),e._v(" in the text-like form "),n("code",[e._v("a function b")]),e._v(". This is called "),n("em",[e._v("infix notation")]),e._v(". Only functions defined using the "),n("code",[e._v("infix")]),e._v(" keyword can be called this way. "),n("code",[e._v("AtomicTest.kt")]),e._v(" defines the "),n("code",[e._v("infix")]),e._v(" "),n("code",[e._v("eq")]),e._v(" and "),n("code",[e._v("neq")]),e._v(" used in "),n("code",[e._v("TestingExample.kt")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("expression eq expected\nexpression neq expected\n")])])]),n("p",[n("code",[e._v("eq")]),e._v(" and "),n("code",[e._v("neq")]),e._v(" are flexible—almost anything works as a test expression. If "),n("em",[e._v("expected")]),e._v(" is a "),n("code",[e._v("String")]),e._v(", then "),n("em",[e._v("expression")]),e._v(" is converted to a "),n("code",[e._v("String")]),e._v(" and the two "),n("code",[e._v("String")]),e._v("s are compared. Otherwise, "),n("em",[e._v("expression")]),e._v(" and "),n("em",[e._v("expected")]),e._v(" are compared directly (without converting them first). In either case, the result of "),n("em",[e._v("expression")]),e._v(" appears on the console so you see something when the program runs. Even when the tests succeed, you still see the result on the left of "),n("code",[e._v("eq")]),e._v(" or "),n("code",[e._v("neq")]),e._v(". If "),n("em",[e._v("expression")]),e._v(" and "),n("em",[e._v("expected")]),e._v(" are not equivalent, "),n("code",[e._v("AtomicTest")]),e._v(" shows an error when the program runs.")]),e._v(" "),n("p",[e._v("The last test in "),n("code",[e._v("TestingExample.kt")]),e._v(" intentionally fails so you see an example of failure output. If the two values are not equal, Kotlin displays the corresponding message starting with "),n("code",[e._v("[Error]")]),e._v(". If you uncomment the last line and run the example above, you will see, after all the successful tests:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("[Error] Epistimology != Ontology\n")])])]),n("p",[e._v("The actual value stored in "),n("code",[e._v("v2")]),e._v(" is not what it is claimed to be in the “expected” expression. "),n("code",[e._v("AtomicTest")]),e._v(" displays the "),n("code",[e._v("String")]),e._v(" representations for both expected and actual values.")]),e._v(" "),n("p",[n("code",[e._v("eq")]),e._v(" and "),n("code",[e._v("neq")]),e._v(" are the basic (infix) functions defined for "),n("code",[e._v("AtomicTest")]),e._v("—it truly is a minimal testing system. When you put "),n("code",[e._v("eq")]),e._v(" and "),n("code",[e._v("neq")]),e._v(" expressions in your examples, you’ll create both a test and some console output. You verify the correctness of the program by running it.")]),e._v(" "),n("p",[e._v("There’s a second tool in "),n("code",[e._v("AtomicTest")]),e._v(". The "),n("code",[e._v("trace")]),e._v(" object captures output for later comparison:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Testing/Trace1.kt\nimport atomictest.*\n\nfun main() {\n  trace("line 1")\n  trace(47)\n  trace("line 2")\n  trace eq """\n    line 1\n    47\n    line 2\n  """\n}\n')])])]),n("p",[e._v("Adding results to "),n("code",[e._v("trace")]),e._v(" looks like a function call, so you can effectively replace "),n("code",[e._v("println()")]),e._v(" with "),n("code",[e._v("trace()")]),e._v(".")]),e._v(" "),n("p",[e._v("In previous atoms, we displayed output and relied on human visual inspection to catch any discrepancies. That’s unreliable; even in a book where we scrutinize the code over and over, we’ve learned that visual inspection can’t be trusted to find errors. From now on we rarely use commented output blocks because "),n("code",[e._v("AtomicTest")]),e._v(" will do everything for us. However, sometimes we still include commented output blocks when that produces a more useful effect.")]),e._v(" "),n("p",[e._v("Seeing the benefits of using testing throughout the rest of the book should help you incorporate testing into your programming process. You’ll probably start feeling uncomfortable when you see code that doesn’t have tests. You might even decide that code without tests is broken by definition.")]),e._v(" "),n("h3",{attrs:{id:"testing-as-part-of-programming"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#testing-as-part-of-programming"}},[e._v("#")]),e._v(" Testing as Part of Programming")]),e._v(" "),n("p",[e._v("Testing is most effective when it’s built into your software development process. Writing tests ensures you get the results you expect. Many people advocate writing tests "),n("em",[e._v("before")]),e._v(" writing the implementation code—you first make the test fail before you write the code to make it pass. This technique, called "),n("em",[e._v("Test Driven Development")]),e._v(" (TDD), is a way to ensure that you’re really testing what you think you are. You’ll find a more complete description of TDD on Wikipedia (search for “Test Driven Development”).")]),e._v(" "),n("p",[e._v("There’s another benefit to writing testably—it changes the way you craft your code. You could just display the results on the console. But in the test mindset you wonder, “How will I test this?” When you create a function, you decide you should return something from the function, if for no other reason than to test that result. Functions that do nothing but take input and produce output tend to generate better designs, as well.")]),e._v(" "),n("p",[e._v("Here’s a simplified example using TDD to implement the BMI calculation from [Number Types](javascript:void(0)). First, we write the tests, along with an initial implementation that fails (because we haven’t yet implemented the functionality):")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Testing/TDDFail.kt\npackage testing1\nimport atomictest.eq\n\nfun main() {\n  calculateBMI(160, 68) eq "Normal weight"\n//  calculateBMI(100, 68) eq "Underweight"\n//  calculateBMI(200, 68) eq "Overweight"\n}\n\nfun calculateBMI(lbs: Int, height: Int) =\n  "Normal weight"\n')])])]),n("p",[e._v("Only the first test passes. The other tests fail and are commented. Next, we add code to determine which weights are in which categories. Now "),n("em",[e._v("all")]),e._v(" the tests fail:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Testing/TDDStillFails.kt\npackage testing2\nimport atomictest.eq\n\nfun main() {\n  // Everything fails:\n  // calculateBMI(160, 68) eq "Normal weight"\n  // calculateBMI(100, 68) eq "Underweight"\n  // calculateBMI(200, 68) eq "Overweight"\n}\n\nfun calculateBMI(\n  lbs: Int,\n  height: Int\n): String {\n  val bmi = lbs / (height * height) * 703.07\n  return if (bmi < 18.5) "Underweight"\n  else if (bmi < 25) "Normal weight"\n  else "Overweight"\n}\n')])])]),n("p",[e._v("We’re using "),n("code",[e._v("Int")]),e._v("s instead of "),n("code",[e._v("Double")]),e._v("s, producing a zero result. The tests guide us to the fix:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Testing/TDDWorks.kt\npackage testing3\nimport atomictest.eq\n\nfun main() {\n  calculateBMI(160.0, 68.0) eq "Normal weight"\n  calculateBMI(100.0, 68.0) eq "Underweight"\n  calculateBMI(200.0, 68.0) eq "Overweight"\n}\n\nfun calculateBMI(\n  lbs: Double,\n  height: Double\n): String {\n  val bmi = lbs / (height * height) * 703.07\n  return if (bmi < 18.5) "Underweight"\n  else if (bmi < 25) "Normal weight"\n  else "Overweight"\n}\n')])])]),n("p",[e._v("You may choose to add additional tests for the boundary conditions.")]),e._v(" "),n("p",[e._v("In the exercises for this book, we include tests that your code must pass.")]),e._v(" "),n("p",[n("em",[n("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);