(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{446:function(e,t,a){"use strict";a.r(t);var n=a(44),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"the-importance-of-lambdas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-importance-of-lambdas"}},[e._v("#")]),e._v(" The Importance of Lambdas")]),e._v(" "),a("blockquote",[a("p",[e._v("Lambdas may seem like syntax sugar, but they provide important power to your programming.")])]),e._v(" "),a("p",[e._v("Code often manipulates the contents of a collection, and typically repeats these manipulations with minor modifications. Consider selecting elements from a collection, such as people under a given age, employees with a specific role, citizens of a particular city, or unfinished orders. Here’s an example that selects even numbers from a list. Suppose we don’t have a rich library of functions for working with collections—we’d have to implement our own "),a("code",[e._v("filterEven()")]),e._v(" operation:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/FilterEven.kt\npackage importanceoflambdas\nimport atomictest.eq\n\nfun filterEven(nums: List<Int>): List<Int> {\n  val result = mutableListOf<Int>()\n  for (i in nums) {\n    if (i % 2 == 0) {    // [1]\n      result += i\n    }\n  }\n  return result\n}\n\nfun main() {\n  filterEven(listOf(1, 2, 3, 4)) eq\n    listOf(2, 4)\n}\n")])])]),a("p",[e._v("If an element has a remainder of 0 when divided by 2, it’s appended to the result.")]),e._v(" "),a("p",[e._v("Imagine you need something similar, but for numbers that are greater than 2. You can copy "),a("code",[e._v("filterEven()")]),e._v(" and modify the small part that chooses the elements included in the result:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/GreaterThan2.kt\npackage importanceoflambdas\nimport atomictest.eq\n\nfun greaterThan2(nums: List<Int>): List<Int> {\n  val result = mutableListOf<Int>()\n  for (i in nums) {\n    if (i > 2) {         // [1]\n      result += i\n    }\n  }\n  return result\n}\n\nfun main() {\n  greaterThan2(listOf(1, 2, 3, 4)) eq\n    listOf(3, 4)\n}\n")])])]),a("p",[e._v("The only notable difference between the previous two examples is the line of code ("),a("strong",[e._v("[1]")]),e._v(" in both cases) specifying the desired elements.")]),e._v(" "),a("p",[e._v("With lambdas, we can use the same function for both cases. The standard library function "),a("code",[e._v("filter()")]),e._v(" takes a predicate specifying the elements you want to preserve, and this predicate can be a lambda:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/Filter.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 2, 3, 4)\n  val even = list.filter { it % 2 == 0 }\n  val greaterThan2 = list.filter { it > 2 }\n  even eq listOf(2, 4)\n  greaterThan2 eq listOf(3, 4)\n}\n")])])]),a("p",[e._v("Now we have clear, concise code that avoids repetition. Both "),a("code",[e._v("even")]),e._v(" and "),a("code",[e._v("greaterThan2")]),e._v(" use "),a("code",[e._v("filter()")]),e._v(" and differ only in the predicate. "),a("code",[e._v("filter()")]),e._v(" has been heavily tested, so you’re less likely to introduce a bug.")]),e._v(" "),a("p",[e._v("Notice that "),a("code",[e._v("filter()")]),e._v(" handles the iteration that would otherwise require handwritten code. Although managing the iteration yourself might not seem like much effort, it’s one more error-prone detail and one more place to make a mistake. Because they’re so “obvious,” such mistakes are particularly hard to find.")]),e._v(" "),a("p",[e._v("This is one of the hallmarks of "),a("em",[e._v("functional programming")]),e._v(", of which "),a("code",[e._v("map()")]),e._v(" and "),a("code",[e._v("filter()")]),e._v(" are examples. Functional programming solves problems in small steps. The functions often do things that seem trivial—it’s not that hard to write your own code rather than using "),a("code",[e._v("map()")]),e._v(" and "),a("code",[e._v("filter()")]),e._v(". However, once you have a collection of these small, debugged solutions, you can easily combine them without debugging at every level. This allows you to create more robust code, more quickly.")]),e._v(" "),a("p",[e._v("You can store a lambda in a "),a("code",[e._v("var")]),e._v(" or "),a("code",[e._v("val")]),e._v(". This allows reuse of that lambda’s logic, by passing it as an argument to different functions:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/StoringLambda.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 2, 3, 4)\n  val isEven = { e: Int -> e % 2 == 0 }\n  list.filter(isEven) eq listOf(2, 4)\n  list.any(isEven) eq true\n}\n")])])]),a("p",[a("code",[e._v("isEven")]),e._v(" checks whether a number is even, and this reference is passed as an argument to both "),a("code",[e._v("filter()")]),e._v(" and "),a("code",[e._v("any()")]),e._v(". The library function "),a("code",[e._v("any()")]),e._v(" checks whether there’s at least one element in the "),a("code",[e._v("List")]),e._v(" satisfying a given predicate. When we define "),a("code",[e._v("isEven")]),e._v(" we must specify the parameter type because there is no context for the type inferencer.")]),e._v(" "),a("p",[e._v("Another important quality of lambdas is the ability to refer to elements outside their scope. When a function “closes over” or “captures” the elements in its environment, we call it a "),a("em",[e._v("closure")]),e._v(".  Unfortunately, some languages conflate the term “closure” with the idea of a lambda. The two concepts are completely distinct: you can have lambdas without closures, and closures without lambdas.")]),e._v(" "),a("p",[e._v("When a language supports closures, it “just works” the way you expect:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/Closures.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 5, 7, 10)\n  val divider = 5\n  list.filter { it % divider == 0 } eq\n    listOf(5, 10)\n}\n")])])]),a("p",[e._v("Here, the lambda “captures” the "),a("code",[e._v("val divider")]),e._v(" that is defined outside the lambda. The lambda not only reads captured elements, it can also modify them:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/Closures2.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 5, 7, 10)\n  var sum = 0\n  val divider = 5\n  list.filter { it % divider == 0 }\n    .forEach { sum += it }\n  sum eq 15\n}\n")])])]),a("p",[e._v("The "),a("code",[e._v("forEach()")]),e._v(" library function applies the specified action to each element of the collection.")]),e._v(" "),a("p",[e._v("Although you can capture the mutable variable "),a("code",[e._v("sum")]),e._v(" as in "),a("code",[e._v("Closures2.kt")]),e._v(", you can usually change your code and avoid modifying the state of your environment:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/Sum.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 5, 7, 10)\n  val divider = 5\n  list.filter { it % divider == 0 }\n    .sum() eq 15\n}\n")])])]),a("p",[a("code",[e._v("sum()")]),e._v(" works on a list of numbers, adding all the elements in the list.")]),e._v(" "),a("p",[e._v("An ordinary function can also close over surrounding elements:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ImportanceOfLambdas/FunctionClosure.kt\npackage importanceoflambdas\nimport atomictest.eq\n\nvar x = 100\n\nfun useX() {\n  x++\n}\n\nfun main() {\n  useX()\n  x eq 101\n}\n")])])]),a("p",[a("code",[e._v("useX()")]),e._v(" captures and modifies "),a("code",[e._v("x")]),e._v(" from its surroundings.")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);