(window.webpackJsonp=window.webpackJsonp||[]).push([[200],{582:function(e,n,t){"use strict";t.r(n);var a=t(44),o=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"using-operators"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#using-operators"}},[e._v("#")]),e._v(" Using Operators")]),e._v(" "),t("blockquote",[t("p",[e._v("In practice you rarely overload operators—usually only when you create your own library.")])]),e._v(" "),t("p",[e._v("However, you regularly "),t("em",[e._v("use")]),e._v(" overloaded operators, often without noticing. For example, the Kotlin standard library defines numerous operators that improve your experience with collections. Here’s some familiar code seen from a new angle:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// UsingOperators/NewAngle.kt\nimport atomictest.eq\n\nfun main() {\n  val list = MutableList(10) { 'a' + it }\n  list[7] eq 'h' // operator get()\n  list.get(8) eq 'i' // Explicit call\n  list[9] = 'x' // operator set()\n  list.set(9, 'x') // Explicit call\n  list[9] eq 'x'\n  ('d' in list) eq true // operator contains()\n  list.contains('e') eq true // Explicit call\n}\n")])])]),t("p",[e._v("Accessing list elements using square brackets calls the overloaded operators "),t("code",[e._v("get()")]),e._v(" and "),t("code",[e._v("set()")]),e._v(", while "),t("code",[e._v("in")]),e._v(" calls "),t("code",[e._v("contains()")]),e._v(".")]),e._v(" "),t("p",[e._v("Calling "),t("code",[e._v("+=")]),e._v(" on a mutable collection modifies it, while calling "),t("code",[e._v("+")]),e._v(" returns a new collection containing the old elements together with the new element:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// UsingOperators/OperatorPlus.kt\nimport atomictest.eq\n\nfun main() {\n  val mutableList = mutableListOf(1, 2, 3)\n  mutableList += 4  // operator plusAssign()\n  mutableList.plusAssign(5) // Explicit\n  mutableList eq "[1, 2, 3, 4, 5]"\n  mutableList + 99 eq "[1, 2, 3, 4, 5, 99]"\n  mutableList eq "[1, 2, 3, 4, 5]"\n  val list = listOf(1)  // Read-only\n  val newList = list + 2  // operator plus()\n  list eq "[1]"\n  newList eq "[1, 2]"\n  val another = list.plus(3)  // Explicit\n  another eq "[1, 3]"\n}\n')])])]),t("p",[e._v("Calling "),t("code",[e._v("+=")]),e._v(" on a read-only collection probably doesn’t produce what you expect:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// UsingOperators/Unexpected.kt\nimport atomictest.eq\n\nfun main() {\n  var list = listOf(1, 2)\n  list += 3  // Probably unexpected\n  list eq "[1, 2, 3]"\n}\n')])])]),t("p",[e._v("In a mutable collection, "),t("code",[e._v("a += b")]),e._v(" calls "),t("code",[e._v("plusAssign()")]),e._v(" to modify "),t("code",[e._v("a")]),e._v(". However, "),t("code",[e._v("plusAssign()")]),e._v(" is not available for read-only collections, so Kotlin rewrites "),t("code",[e._v("a += b")]),e._v(" into "),t("code",[e._v("a = a + b")]),e._v(". This calls "),t("code",[e._v("plus()")]),e._v(", which doesn’t change the collection, but rather creates a new one and assigns the result to the "),t("code",[e._v("var")]),e._v(" "),t("code",[e._v("list")]),e._v(" reference. The net effect is that "),t("code",[e._v("a += b")]),e._v(" still produces the result we expect for "),t("code",[e._v("a")]),e._v("—at least for simple types like "),t("code",[e._v("Int")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// UsingOperators/ReadOnlyAndPlus.kt\nimport atomictest.eq\n\nfun main() {\n  var list = listOf(1, 2)\n  val initial = list\n  list += 3\n  list eq "[1, 2, 3]"\n  list = list.plus(4)\n  list eq "[1, 2, 3, 4]"\n  initial eq "[1, 2]"\n}\n')])])]),t("p",[e._v("The last line shows that the "),t("code",[e._v("initial")]),e._v(" collection remains unchanged. Creating a new collection for every added element probably isn’t your intent. The problem doesn’t arise if you use "),t("code",[e._v("val")]),e._v(" for "),t("code",[e._v("list")]),e._v(" instead of "),t("code",[e._v("var")]),e._v(" because calling "),t("code",[e._v("+=")]),e._v(" won’t compile. This is one more reason to use "),t("code",[e._v("val")]),e._v(" by default—only use "),t("code",[e._v("var")]),e._v(" when necessary.")]),e._v(" "),t("p",[t("code",[e._v("compareTo()")]),e._v(" was introduced as a standalone extension function in [Operator Overloading](javascript:void(0)). However, you get greater benefits if your class implements the "),t("code",[e._v("Comparable")]),e._v(" interface and overrides its "),t("code",[e._v("compareTo()")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// UsingOperators/CompareTo.kt\npackage usingoperators\nimport atomictest.eq\n\ndata class Contact(\n  val name: String,\n  val mobile: String\n): Comparable<Contact> {\n  override fun compareTo(\n    other: Contact\n  ): Int = name.compareTo(other.name)\n}\n\nfun main() {\n  val alice = Contact("Alice", "0123456789")\n  val bob = Contact("Bob", "9876543210")\n  val carl = Contact("Carl", "5678901234")\n  (alice < bob) eq true\n  (alice <= bob) eq true\n  (alice > bob) eq false\n  (alice >= bob) eq false\n  val contacts = listOf(bob, carl, alice)\n  contacts.sorted() eq\n    listOf(alice, bob, carl)\n  contacts.sortedDescending() eq\n    listOf(carl, bob, alice)\n}\n')])])]),t("p",[e._v("Any two "),t("code",[e._v("Comparable")]),e._v("s can be compared using "),t("code",[e._v("<")]),e._v(", "),t("code",[e._v("<=")]),e._v(", "),t("code",[e._v(">")]),e._v(" and "),t("code",[e._v(">=")]),e._v(" (note that "),t("code",[e._v("==")]),e._v(" and "),t("code",[e._v("!=")]),e._v(" are not included). Kotlin doesn’t require the "),t("code",[e._v("operator")]),e._v(" modifier when overriding "),t("code",[e._v("compareTo()")]),e._v(" because it has already been defined as an "),t("code",[e._v("operator")]),e._v(" in the "),t("code",[e._v("Comparable")]),e._v(" interface.")]),e._v(" "),t("p",[e._v("Implementing "),t("code",[e._v("Comparable")]),e._v(" also enables features like sortability, and creating a range of instances without redefining the "),t("code",[e._v("..")]),e._v(" operator. You can then check to see if a value is "),t("code",[e._v("in")]),e._v(" that range:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// UsingOperators/ComparableRange.kt\npackage usingoperators\nimport atomictest.eq\n\nclass F(val i: Int): Comparable<F> {\n  override fun compareTo(other: F) =\n    i.compareTo(other.i)\n}\n\nfun main() {\n  val range = F(1)..F(7)\n  (F(3) in range) eq true\n  (F(9) in range) eq false\n}\n")])])]),t("p",[e._v("Prefer implementing "),t("code",[e._v("Comparable")]),e._v(". Only define "),t("code",[e._v("compareTo()")]),e._v(" as an extension function when using a class you have no control over.")]),e._v(" "),t("h3",{attrs:{id:"destructuring-operators"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#destructuring-operators"}},[e._v("#")]),e._v(" Destructuring Operators")]),e._v(" "),t("p",[e._v("Another group of operators you don’t typically define is the "),t("code",[e._v("componentN()")]),e._v(" functions ("),t("code",[e._v("component1()")]),e._v(", "),t("code",[e._v("component2()")]),e._v(" etc.), used for [Destructuring Declarations](javascript:void(0)). In "),t("code",[e._v("main()")]),e._v(", Kotlin quietly generates calls to "),t("code",[e._v("component1()")]),e._v(" and "),t("code",[e._v("component2()")]),e._v(" for the destructuring assignment:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// UsingOperators/DestructuringDuo.kt\npackage usingoperators\nimport atomictest.*\n\nclass Duo(val x: Int, val y: Int) {\n  operator fun component1(): Int {\n    trace("component1()")\n    return x\n  }\n  operator fun component2(): Int {\n    trace("component2()")\n    return y\n  }\n}\n\nfun main() {\n  val (a, b) = Duo(1, 2)\n  a eq 1\n  b eq 2\n  trace eq "component1() component2()"\n}\n')])])]),t("p",[e._v("The same approach works with "),t("code",[e._v("Map")]),e._v("s, which use an "),t("code",[e._v("Entry")]),e._v(" type containing "),t("code",[e._v("component1()")]),e._v(" and "),t("code",[e._v("component2()")]),e._v(" member functions:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// UsingOperators/DestructuringMap.kt\nimport atomictest.eq\n\nfun main() {\n  val map = mapOf("a" to 1)\n  for ((key, value) in map) {\n    key eq "a"\n    value eq 1\n  }\n  // The Destructuring assignment becomes:\n  for (entry in map) {\n    val key = entry.component1()\n    val value = entry.component2()\n    key eq "a"\n    value eq 1\n  }\n}\n')])])]),t("p",[e._v("You can use destructuring declarations with any "),t("code",[e._v("data")]),e._v(" class because "),t("code",[e._v("componentN()")]),e._v(" functions are automatically generated:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// UsingOperators/DestructuringData.kt\npackage usingoperators\nimport atomictest.eq\n\ndata class Person(\n  val name: String,\n  val age: Int\n) {\n  // Compiler generates:\n  // fun component1() = name\n  // fun component2() = age\n}\n\nfun main() {\n  val person = Person("Alice", 29)\n  val (name, age) = person\n  // The Destructuring assignment becomes:\n  val name_ = person.component1()\n  val age_ = person.component2()\n  name eq "Alice"\n  age eq 29\n  name_ eq "Alice"\n  age_ eq 29\n}\n')])])]),t("p",[e._v("Kotlin generates a "),t("code",[e._v("componentN()")]),e._v(" function for each property.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);