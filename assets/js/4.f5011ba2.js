(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{376:function(e,n,t){e.exports=t.p+"assets/img/recursion-call-stack.4b886dcb.png"},377:function(e,n,t){e.exports=t.p+"assets/img/recursion-infinite-recursion.7826cfae.png"},378:function(e,n,t){e.exports=t.p+"assets/img/recursion-regular-recursion-vs-tail-recursion.64650288.png"},379:function(e,n,t){e.exports=t.p+"assets/img/recursion-inefficient-fibonacci.ecbfc852.png"},552:function(e,n,t){"use strict";t.r(n);var a=t(44),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"recursion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recursion"}},[e._v("#")]),e._v(" Recursion")]),e._v(" "),a("blockquote",[a("p",[a("em",[e._v("Recursion")]),e._v(" is the programming technique of calling a function within that same function. "),a("em",[e._v("Tail recursion")]),e._v(" is an optimization that can be explicitly applied to some recursive functions.")])]),e._v(" "),a("p",[e._v("A recursive function uses the result of the previous recursive call. Factorials are a common example—"),a("code",[e._v("factorial(n)")]),e._v(" multiplies all numbers from "),a("code",[e._v("1")]),e._v(" to "),a("code",[e._v("n")]),e._v(", and can be defined like this:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("factorial(1)")]),e._v(" is "),a("code",[e._v("1")])]),e._v(" "),a("li",[a("code",[e._v("factorial(n)")]),e._v(" is "),a("code",[e._v("n * factorial(n - 1)")])])]),e._v(" "),a("p",[a("code",[e._v("factorial()")]),e._v(" is recursive because it uses the result from the same function applied to its modified argument. Here’s a recursive implementation of "),a("code",[e._v("factorial()")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Recursion/Factorial.kt\npackage recursion\nimport atomictest.eq\n\nfun factorial(n: Long): Long {\n  if (n <= 1) return 1\n  return n * factorial(n - 1)\n}\n\nfun main() {\n  factorial(5) eq 120\n  factorial(17) eq 355687428096000\n}\n")])])]),a("p",[e._v("While this is easy to read, it’s expensive. When calling a function, the information about that function and its arguments are stored in a "),a("em",[e._v("call stack")]),e._v(". You see the call stack when an exception is thrown and Kotlin displays the "),a("em",[e._v("stack trace")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Recursion/CallStack.kt\npackage recursion\n\nfun illegalState() {\n  // throw IllegalStateException()\n}\n\nfun fail() = illegalState()\n\nfun main() {\n  fail()\n}\n")])])]),a("p",[e._v("If you uncomment the line containing the exception, you’ll see the following:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Exception in thread "main" java.lang.IllegalStateException\n  at recursion.CallStackKt.illegalState(CallStack.kt:5)\n  at recursion.CallStackKt.fail(CallStack.kt:8)\n  at recursion.CallStackKt.main(CallStack.kt:11)\n')])])]),a("p",[e._v("The stack trace displays the state of the call stack at the moment the exception is thrown. For "),a("code",[e._v("CallStack.kt")]),e._v(", the call stack consists of only three functions:")]),e._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"10%"},attrs:{src:t(376),alt:"recursion call stack"}}),e._v(" "),a("p",[e._v("The Call Stack ")])]),e._v(" "),a("p",[e._v("We start in "),a("code",[e._v("main()")]),e._v(", which calls "),a("code",[e._v("fail()")]),e._v(". The "),a("code",[e._v("fail()")]),e._v(" call is added to the call stack along with its arguments. Next, "),a("code",[e._v("fail()")]),e._v(" calls "),a("code",[e._v("illegalState()")]),e._v(", which is also added to the call stack.")]),e._v(" "),a("p",[e._v("When you call a recursive function, each recursive invocation adds a frame to the call stack. This can easily produce a "),a("code",[e._v("StackOverflowError")]),e._v(", which means that your call stack became too large and exhausted the available memory.")]),e._v(" "),a("p",[e._v("Programmers commonly cause "),a("code",[e._v("StackOverflowError")]),e._v("s by forgetting to terminate the chain of recursive calls—this is "),a("em",[e._v("infinite recursion")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Recursion/InfiniteRecursion.kt\npackage recursion\n\nfun recurse(i: Int): Int = recurse(i + 1)\n\nfun main() {\n  // println(recurse(1))\n}\n")])])]),a("p",[e._v("If you uncomment the line in "),a("code",[e._v("main()")]),e._v(", you’ll see a stacktrace with many duplicate calls:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Exception in thread "main" java.lang.StackOverflowError\nat recursion.InfiniteRecursionKt.recurse(InfiniteRecursion.kt:4)\nat recursion.InfiniteRecursionKt.recurse(InfiniteRecursion.kt:4)\n...\nat recursion.InfiniteRecursionKt.recurse(InfiniteRecursion.kt:4)\n')])])]),a("p",[e._v("The recursive function keeps calling itself (with a different argument each time), and fills up the call stack:")]),e._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"10%"},attrs:{src:t(377),alt:"recursion infinite recursion"}}),e._v(" "),a("p",[e._v("Infinite Recursion")])]),e._v(" "),a("p",[e._v("Infinite recursion always ends with a "),a("code",[e._v("StackOverflowError")]),e._v(", but you can produce the same result "),a("em",[e._v("without")]),e._v(" infinite recursion, simply by making enough recursive function calls. For example, let’s sum the integers up to a given number, recursively defining "),a("code",[e._v("sum(n)")]),e._v(" as "),a("code",[e._v("n + sum(n - 1)")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Recursion/RecursionLimits.kt\npackage recursion\nimport atomictest.eq\n\nfun sum(n: Long): Long {\n  if (n == 0L) return 0\n  return n + sum(n - 1)\n}\n\nfun main() {\n  sum(2) eq 3\n  sum(1000) eq 500500\n  // sum(100_000) eq 500050000       // [1]\n  (1..100_000L).sum() eq 5000050000  // [2]\n}\n")])])]),a("p",[e._v("This recursion quickly becomes expensive. If you uncomment line "),a("strong",[e._v("[1]")]),e._v(", you’ll discover that it takes far too long to complete, and all those recursive calls overflow the stack. If "),a("code",[e._v("sum(100_000)")]),e._v(" still works on your machine, try a bigger number.")]),e._v(" "),a("p",[e._v("Calling "),a("code",[e._v("sum(100_000)")]),e._v(" causes a "),a("code",[e._v("StackOverflowError")]),e._v(" by adding "),a("code",[e._v("100_000")]),e._v(" "),a("code",[e._v("sum()")]),e._v(" function calls to the call stack. For comparison, line "),a("strong",[e._v("[2]")]),e._v(" uses the "),a("code",[e._v("sum()")]),e._v(" library function to add the numbers within the range, and this does not fail.")]),e._v(" "),a("p",[e._v("To avoid a "),a("code",[e._v("StackOverflowError")]),e._v(", you can use an iterative solution instead of recursion:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Recursion/Iteration.kt\npackage iteration\nimport atomictest.eq\n\nfun sum(n: Long): Long {\n  var accumulator = 0L\n  for (i in 1..n) {\n    accumulator += i\n  }\n  return accumulator\n}\n\nfun main() {\n  sum(10000) eq 50005000\n  sum(100000) eq 5000050000\n}\n")])])]),a("p",[e._v("There’s no risk of a "),a("code",[e._v("StackOverflowError")]),e._v(" because we only make a single "),a("code",[e._v("sum()")]),e._v(" call and the result is calculated in a "),a("code",[e._v("for")]),e._v(" loop. Although the iterative solution is straightforward, it must use the mutable state variable "),a("code",[e._v("accumulator")]),e._v(" to store the changing value, and functional programming attempts to avoid mutation.")]),e._v(" "),a("p",[e._v("To prevent call stack overflows, functional languages (including Kotlin) use a technique called "),a("em",[e._v("tail recursion")]),e._v(". The goal of tail recursion is to reduce the size of the call stack. In the "),a("code",[e._v("sum()")]),e._v(" example, the call stack becomes a single function call, just as it did in "),a("code",[e._v("Iteration.kt")]),e._v(":")]),e._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"10%"},attrs:{src:t(378),alt:"recursion regular recursion vs tail recursion"}}),e._v(" "),a("p",[e._v("Regular Recursion vs. Tail Recursion")])]),e._v(" "),a("p",[e._v("To produce tail recursion, use the "),a("code",[e._v("tailrec")]),e._v(" keyword. Under the right conditions, this converts recursive calls into iteration, eliminating call-stack overhead. This is a compiler optimization, but it won’t work for just any recursive call.")]),e._v(" "),a("p",[e._v("To use "),a("code",[e._v("tailrec")]),e._v(" successfully, recursion must be the final operation, which means there can be no extra calculations on the result of the recursive call before it is returned. For example, if we simply put "),a("code",[e._v("tailrec")]),e._v(" before the "),a("code",[e._v("fun")]),e._v(" for "),a("code",[e._v("sum()")]),e._v(" in "),a("code",[e._v("RecursionLimits.kt")]),e._v(", Kotlin produces the following warning messages:")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("A function is marked as tail-recursive but no tail calls are found")])]),e._v(" "),a("li",[a("em",[e._v("Recursive call is not a tail call")])])]),e._v(" "),a("p",[e._v("The problem is that "),a("code",[e._v("n")]),e._v(" is combined with the result of the recursive "),a("code",[e._v("sum()")]),e._v(" call "),a("em",[e._v("before")]),e._v(" returning that result. For "),a("code",[e._v("tailrec")]),e._v(" to be successful, the result of the recursive call must be returned without doing anything to it during the return. This often requires some work in rearranging the function. For "),a("code",[e._v("sum()")]),e._v(", a successful "),a("code",[e._v("tailrec")]),e._v(" looks like this:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Recursion/TailRecursiveSum.kt\npackage tailrecursion\nimport atomictest.eq\n\nprivate tailrec fun sum(\n  n: Long,\n  accumulator: Long\n): Long =\n  if (n == 0L) accumulator\n  else sum(n - 1, accumulator + n)\n\nfun sum(n: Long) = sum(n, 0)\n\nfun main() {\n  sum(2) eq 3\n  sum(10000) eq 50005000\n  sum(100000) eq 5000050000\n}\n")])])]),a("p",[e._v("By including the "),a("code",[e._v("accumulator")]),e._v(" parameter, the addition happens during the recursive call and you don’t do anything to the result except return it. The "),a("code",[e._v("tailrec")]),e._v(" keyword is now successful, because the code was rewritten to delegate all activities to the recursive call. In addition, "),a("code",[e._v("accumulator")]),e._v(" becomes an immutable value, eliminating the complaint we had for "),a("code",[e._v("Iteration.kt")]),e._v(".")]),e._v(" "),a("p",[a("code",[e._v("factorial()")]),e._v(" is a common example for demonstrating tail recursion, and is one of the exercises for this atom. Another example is the Fibonacci sequence, where each new Fibonacci number is the sum of the previous two. The first two numbers are "),a("code",[e._v("0")]),e._v(" and "),a("code",[e._v("1")]),e._v(", which produces the following sequence: "),a("code",[e._v("0, 1, 1, 2, 3, 5, 8, 13, 21 ...")]),e._v(" This can be expressed recursively:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Recursion/VerySlowFibonacci.kt\npackage slowfibonacci\nimport atomictest.eq\n\nfun fibonacci(n: Long): Long {\n  return when (n) {\n    0L -> 0\n    1L -> 1\n    else ->\n      fibonacci(n - 1) + fibonacci(n - 2)\n  }\n}\n\nfun main() {\n  fibonacci(0) eq 0\n  fibonacci(22) eq 17711\n  // Very time-consuming:\n  // fibonacci(50) eq 12586269025\n}\n")])])]),a("p",[e._v("This implementation is terribly inefficient because the previously-calculated results are not reused. Thus, the number of operations grows exponentially:")]),e._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"10%"},attrs:{src:t(379),alt:"recursion-inefficient-fibonacci"}}),e._v(" "),a("p",[e._v("Inefficient Computation of Fibonacci Numbers")])]),e._v(" "),a("p",[e._v("When computing the 50th Fibonacci number, we first compute the 49th and 48th numbers independently, which means we compute the 48th number twice. The 46th number is computed as many as 4 times, and so on.")]),e._v(" "),a("p",[e._v("Using tail recursion, the calculations become dramatically more efficient:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Recursion/Fibonacci.kt\npackage recursion\nimport atomictest.eq\n\nfun fibonacci(n: Int): Long {\n  tailrec fun fibonacci(\n    n: Int,\n    current: Long,\n    next: Long\n  ): Long {\n    if (n == 0) return current\n    return fibonacci(\n      n - 1, next, current + next)\n  }\n  return fibonacci(n, 0L, 1L)\n}\n\nfun main() {\n  (0..8).map { fibonacci(it) } eq\n    "[0, 1, 1, 2, 3, 5, 8, 13, 21]"\n  fibonacci(22) eq 17711\n  fibonacci(50) eq 12586269025\n}\n')])])]),a("p",[e._v("We could avoid the local "),a("code",[e._v("fibonacci()")]),e._v(" function using default arguments. However, default arguments imply that the user can put other values in those defaults, which produce incorrect results. Because the auxiliary "),a("code",[e._v("fibonacci()")]),e._v(" function is a local function, we don’t expose the additional parameters, and you can "),a("em",[e._v("only")]),e._v(" call "),a("code",[e._v("fibonacci(n)")]),e._v(".")]),e._v(" "),a("p",[a("code",[e._v("main()")]),e._v(" shows the first eight elements of the Fibonacci sequence, the result for 22, and finally the 50th Fibonacci number that is now produced very quickly.")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);